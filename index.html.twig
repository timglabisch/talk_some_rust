<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/idea.css">

		<script src="jquery-3.0.0.min.js"></script>

		<style>
			iframe {
				max-width: 100% !important;
			}

			pre {
				box-shadow: none !important;
			}

			.right-code {
				border-left: 1px solid silver !important;
			}

			section img {
				border: 1px solid #ccc !important;
			}

			.editor img {
				max-width: 50%;
				border: 0 !important;
				box-shadow: none !important;
			}

			.reveal pre code {
				max-height: inherit !important;
			}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<script type="application/javascript">
            $(document).ready(function() {
                $('.editor').each(function (i, v) {

                    $(v).css({
                        'height': $(document).height() - 100,
                        'border': '1px solid silver',
                        'display': 'flex',
                        'justify-content': 'flex-start'
                    });

                    let rust_pen = "http://127.0.0.1:5000";
                    //var rust_pen = "https://play.rust-lang.org/";

                    let rust_code = $(v).data('code-rust');


                    $(v).html('');


                    if (rust_code) {
                        $(v).append($('<iframe style="flex: 1 1 auto;overflow:scroll"/>').attr('src', rust_pen + '/?pageMode=presentation&code=' + encodeURIComponent(rust_code)));
                    }

					let php_code = $(v).data('code-php');
                    if (php_code && php_code.trim()) {
                        let php_code_node = $('<div class="right-code"><pre><code data-trim data-noescape class="code"></code></pre></div>');
						php_code_node.find('.code').text(php_code);
						$(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(php_code_node));
						return;
                    }

                    let html_code = $(v).data('code-html');
                    if (html_code && html_code.trim()) {
						$(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(html_code));
						return;
                    }

                });

                $('.editor > *').each(function(i, v) {
                    //$(v).css('margin', '10px');
                }).mouseenter(function(e) {
                    $(e.target).css('flex', '95 1 auto');
                    $(e.target).siblings().css('width', 100);
                    $(e.target).siblings().css('flex', '1 1 auto');
                })
                    .mouseleave(function(e) {
                        $(e.target).css('flex', '1 1 auto');
                        $(e.target).css('width', '');
                        $(e.target).siblings().css('width', '');
                    });
            });


		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    {% embed "twig/editor.html.twig" %}
                        {% block rust %}
// if you can't read this,
// take another seat.
fn main() {
	println!("hello rheinjug");
}
                        {% endblock %}

                        {% block php %}
// kotlin
fun main(args: Array<String>) {
	println("hello rheinjug");
}

// php
echo "hello rheinjug";
                        {% endblock %}
                    {% endembed %}
						<aside class="notes">
							<ul>
								<li>Hi!</li>
								<li>ich hab euch auf der ersten slide schon code mitgebracht.</li>
								<li>es ist wichtig, dass ihr das halbwegs gut lesen könnt, sonst wird der vortrag sehr langweilig.</li>
								<li>nun zum code. - was haben wir hier? ja eine begrüßung</li>
								<li>oft hab ich code in mehreren sprachen mitgebracht, ich finds am einfachsten wenn man diesen vergleicht.</li>
								<li>der rust code ist immer executable, d.h. wir können zusammen auch im code basteln und ausprobieren.</li>
								<li>generell hab ich aber recht viele slides :) - könnt aber jederzeit rein quatschen.</li>
								<li>
									nun zum code. sieht erstmal ähnlich aus, unterschiede?
									<ul>
										<li>argumente der main function</li>
										<li>rust hat ! :) macro</li>
										<li>UTF8 vs. UTF 16 vs bytecode</li>
									</ul>
								</li>
							</ul>
						</aside>
				</section>

					<section>
						<img src="img/me.jpeg" style="max-width:230px">

						<br/>
						<i>@timglabisch</i>

						<br/>
						<img src="img/github_stats.png" style="max-width:370px"/>
						<aside class="notes">
							<ul>
								<li>Ich bin Tim</li>
								<li>
									... Und Github denkt ich würde in diesen Sprachen entwickeln
									<ul>
										<li>Das ist definitiv falsch, ich mach kein Basic x)</li>
										<li>und CSS ist dieser Talk ^^</li>
										<li>gibt aber vielleicht ein ganz guten Überblick über meinen "sprachlichen" Background</li>
									</ul>
								</li>
								<li>
									Ich arbeite für Easybill, platform zum rechnungen schreiben und mache primär PHP.
								</li>
								<li>
									Früher war ich viel als PHP Consult unterwegs.
								</li>
								<li>
									Hatte ja schon angekündigt, dass der Talk sehr codelastig wird.
									<ul>
										<li>Ich hab aber auch viele Slides mitgebracht</li>
										<li>Sollte ich euch deutlich zu schnell werden, einfach aufschreien oder mit irgendwas nach mir werfen.</li>
									</ul>
								</li>
							</ul>
						</aside>
					</section>

					<section data-background="img/rust_rain.gif">
					</section>

					<section>
						<p class="fragment" data-fragment-index="0">Modern</p>
						<p class="fragment" data-fragment-index="1">Stable (& used)</p>
						<p class="fragment" data-fragment-index="2">Large Projects</p>
						<p class="fragment" data-fragment-index="3">Huge, great community</p>
						<p class="fragment" data-fragment-index="4">Tooling</p>
						<p class="fragment" data-fragment-index="5"><strong>Fast</strong> (like C / C++)</p>
						<p class="fragment" data-fragment-index="6">Zero Cost Abstractions</p>
						<p class="fragment" data-fragment-index="7"><strong>Safe</strong> (no Seqfaults, Dataraces, ...)</p>
						<p class="fragment" data-fragment-index="8"><strong>Concurrent</strong></p>
						<p class="fragment" data-fragment-index="9">No Runtime (& no GC)</p>

						<aside class="notes">
							<p>
								Wenn rust ein quatett wäre, hier ein ganz kurzer abriss, was es ausmacht.
							</p>
							<ul>
								<li>-</li>
								<li>neue versionen werden gegen alles was im packagemanager existiert getestet</li>
								<li>entwickelt von mozilla weil C++ für Firefox nicht ausreichend skaliert</li>
								<li>
									<ul>
										<li>Dokumentation ist weltklasse</li>
										<li>Mozilla zahlt ein Team um an doku zu arbeiten</li>
										<li>Vorlesungen</li>
									</ul>
								<li>Tooling kommt aus der Ruby ecke, sehr einfach!</li>
								<li>alles dreht sich um Performance (sehr spannend wie gelöst)</li>
								<li>rusts stärke ist, dass es nicht kompiliert</li>
							</ul>
						</aside>
					</section>

					<section>
						<p class="fragment" data-fragment-index="0">
							hard to master
						</p>
						<p class="fragment" data-fragment-index="1">
							<img src="img/we_are_rust.png">
						</p>

						<aside class="notes">
							<ul>
								<li>harte lernkurve - nicht einfach ins team werfen</li>
								<li>sehr expliziter syntax</li>
							</ul>
						</aside>
					</section>

					<section>
						<img src="img/rust_vs_fo_choose_go.png" />
					</section>

					<section>
						<h2>Basics</h2>
						<aside class="notes">
							<ul>
								<li>schauen wir uns basics an?</li>
								<li>was ist erstmal das wichtigste?</li>
								<li>schauen wir uns methodenaufrufe an :)</li>
							</ul>
						</aside>
					</section>

				{#
					<section>
                        {% embed "twig/editor.html.twig" %}
                        {% block rust %}
fn main() {
	let a: &[u8] = b"hello, Rheinjug!";
	println!(
		"{}",
		::std::str::from_utf8(a)
			.expect("i am sure it's valid utf8")
	);
}
                        {% endblock %}

                        {% block php %}
// kotlin
import java.nio.charset.Charset

fun main(args: Array<String>) {
	val a = "Hello Rheinjug"
		.toByteArray(Charset.defaultCharset());
	println(
		String.format(
			"%s",
			a.toString(Charset.defaultCharset())
		)
	);
}

// php
echo(sprintf("%s", "Hello Rheinjug!"));

                        {% endblock %}
                    {% endembed %}


				</section>
#}
				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!(
		"Hello {}",
		name
	);
}

pub fn main() {
	let name = "Rheinjug"
		.to_string();
	greet(name);
}
					{% endblock %}

					{% block php %}
// kotlin
private fun greet(name : String) {
	println("Hello " + name);
}

fun main(args: Array<String>) {
	val name = "Rheinjug";
	greet(name)
}

// php
function greet(string $name) {
	echo sprintf(
		"Hello %s", $name
	);
}

$name = "PHPUG";
greet($name);



					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>fokus auf dne kotlin code.</li>
								<li>main methode -> string wird delariert. funktion wird aufgerufen.</li>
								<li>
									wer von euch macht kotlin?
									<ul>
										<li>ich normal nicht, dacht mir aber, wir sind ja auf der rheinjug =)</li>
									</ul>
								</li>
								<li>
									<ul>
										<li>Hier sehen wir eine Funktion welche aufgerufen wird (greet)</li>
										<li>Typisierung der Funktion (String) ist steht auf der rechten seite Kotlin und Rust machen dies identisch. Java und PHP nicht.</li>
									</ul>
								</li>

								<li>
									ich werde für den Moment noch nicht auf das .to_string() eingehen, vielleicht schaffen wir das gleich noch
									<ul>
										<li>oder hat jemand ne idee?</li>
									</ul>
								</li>

								<li>
									nächstes beispiel. was ist das wichtigste? Klassen!
								</li>
							</ul>
						</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	pub age: i32
}

pub fn main() {
	let tim = Person { age: 27 };
	println!(
		"tim is {} years old",
		tim.age
	);
}
					{% endblock %}

					{% block php %}
class Person(val age : Int);

fun main(args: Array<String>) {
	val tim = Person(27);
	println(
		"tim is "
		+ tim.age
		+ " years old"
	)
}

					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>In Rust definieren wir ein Strukt mit einer Property. in Kotlin eine Klasse.</li>
							<li>Strukts haben felder, Klassen haben properties</li>
							<li>
								Jede sprache hat eine andere ideologie. Sieht man z.b. daran:
								Kotlin ist public by default, Rust ist private by default.
								<ul>
									<li>Kotlin ist eher pragmatisch</li>
									<li>Rust versucht extrem korrekt und expliizit zu ein. werden wir noch öfters sehen.</li>
									<li>anderes beispiel, wir hatten eben da expect beim wandeln in utf8.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	age: i32
}

impl Person {
	pub fn new(age: i32) -> Self {
		Person {
			age
		}
	}

	pub fn get_age(&self) -> i32 {
		self.age
	}
}

pub fn main() {
	let tim = Person::new(27);
	println!("tim is {} years old", tim.get_age());
}
					{% endblock %}

					{% block php %}
class Person(private val age : Int) {
	fun getAge(): Int {
		return this.age;
	}
}

fun main(args: Array<String>) {
	val tim = Person(27);
	println(
		"tim is "
		+ tim.getAge()
		+ " years old"
	)
}


					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>hier das gleiche beipiel mit einem getter.</li>
								<li>
									[kotlin code erklären]
									<ul>
										<li>[private]</li>
									</ul>
								</li>
								<li>
									[zum rust code]
                                    hier sieht man deutliche unterschiede
                                    <ul>
                                        <li>Kotlin code ist weniger</li>
                                        <li>Rust kennt keinen Konstruktur, ist einfach eine statische methode, welche eine Instanz zurückgibt.</li>
										<li>Rust hat keine echten klassen, sieht mehr aus wie golang (impl für ein strukt)</li>
										<li>
											Rust trennt zustand (properties) von Funktionen.
											<ul>
												<li>mehrere impl blöcke pro strukt</li>
												<li>impl blöcke für andere structs</li>
											</ul>
										</li>
										<li>
											Rust nimmt speichermanagement extrem genau, sehen wir später noch.
											<ul>
												<li>
													in kotlin -> Person ist eine Instanz einer Klasse welche im Heap liegt.
												</li>
												<li>
													In Rust ist Person eine Datenstruktur der Größe Integer, welche auf dem Stack liegt. Kein Refcounting etc. Wer weiß, was refcounting ist? später mehr dazu.
												</li>
											</ul>
										</li>
                                    </ul>
                                </li>
							</ul>
						</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>

							<li>wenn man sich in projekten anguckt fühlt man sich mitlerweilse oft so.</li>
							<li>unsere technologielandschaft ähnelt in vielen Projekten oft eher einem Abenteuerspielplatz als einem enterprise projekt</li>

							<!--
							<li>
								da ganze hat 2 seiten
								<ul>
									<li>wir lernen grade software so zu implementieren, dass diese komponenten isoliert und wegwerfbar sind.</li>
									<li>software ist heute mehr wie eine PET-Flasche, man nuckelt dran und wirft ie weg.</li>
									<li>recruiting spielt da auch mit rein, viele wollen schlicht ausprobieren können.</li>
									<li>probiert man nicht aus, sammelt man keine erfahrung</li>
									<li>kunst liegt darin, gefahrlos auszuprobieren</li>
								</ul>
								<ul>
									<li></li>
								</ul>
							</li>
							-->

							<li>agile herangehensweisen machen es einfach mal was neues in ein projekt zu werfen, hype driven development ist gang und gebe</li>
							<li>die meisten entwickler haben mehr javascript frameworks selbst gebau, als das sie algorithmen implementieren können - so ist das eben heute, und ich finds auch nicht schlimm.</li>
							<li>in den letzten paar jahren ist die menge an technologien pro projekt extrem gestiegen, frameworks werden komplexer u.s.w.</li>
							<li>... und nun stelle ich euch mal wieder eine neue technologie vor, welche neue Hoffnung bringen soll. wie jede andere technologie mit der man sich rumschlägt.</li>

							<li>in dem talk möchte ich euch näher bringen, warum ich der meinung bin, dass rust nicht in dieses pattern fällt.</li>
							<li>-> schauen wir uns dazu mal die rust startseite an.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_lang_org_startpage1.png" />
					<aside class="notes">
						<aside class="notes">
							<ul>
								<li>[vorlesen]</li>
								<li>aber was ist eigentlich eine system programming language?</li>
								<li>ist kotlin?</li>
								<li>und rust will "schnell" sein</li>
								<li>ok, nichts neues, das sind C und C++ z.b. auch. und schnell ist ja eh relativ</li>
							</ul>
						</aside>
					</aside>
				</section>
					
				<section>
					<img src="img/system_prgramming_languages.png">
					<a href="https://en.wikipedia.org/wiki/System_programming_language">wikipedia.org/wiki/System_programming_language</a>
					<aside class="notes">
						<ul>
							<li>wikipedia listet 15 system programming languages</li>
							<li>das sind echt wenig sprachen, oder? wenn man mal danach schau, in welchen sprachen tatsächlich betriebsysteme / treiber geschrieben werden, wird die liste kürzer.</li>
							<li>ich bin ehrlich gesagt über swift gestolpert, weil es für mich keine wirkliche system programming language ist.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/swift_system_programming.png">
					<br/>
					<small>
						<a href="https://www.quora.com/Is-Swift-a-great-systems-programming-language">quora.com/Is-Swift-a-great-systems-programming-language</a>
					</small>
				</section>

				<section>
					<img src="img/language_ranking_with_tiobe.png">
					<aside class="notes">
						<ul>
							<li>schaut man mal welche sprachen tatsächlich viel genutzt werden.</li>
							<li>das ist krass, C und C++ sind uralt und unter den ersten Plätzen.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/system_prgramming_languages_reduced.png" style="max-width: 65%">
					<aside class="notes">
						<ul>
							<li>habe mal auf die redudiert die noch einfluss haben und swift entfernt.</li>
							<li>...luft wird dünn...</li>
							<li>wenn man dann schaut wie viele jahre dazwischen liegen</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>
							<li>wird einem erstmal klar, dass es zu dem thema garnicht soviel gibt.</li>
							<li>nun könnte man sagen, ich will garkein C und C++ lernen, wofür dann rust?</li>
							<li>die 31 Jahre zeigen wie schwer es ist.</li>
							<li>was schwer ist, ist oft interessant und man kann viel von lernen.</li>
							<li>mozilla hat rund 6 jahre forschung in die reinen sprachkonzepte gesteckt.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/rust_lang_org_startpage2.png">
					<aside class="notes">
						<ul>
							<li>prevents segfaults - kennt jemand segfaults?</li>
							<li>
								ich programmiere viel php, da sieht man schonmal häufig segfaults. php ist in C geschrieben.
								<ul>
									<li>PHP Intern sind und kein spass zum Debuggen machen</li>
									<li>hab ich häufiger mal wenn ich gewaltige tests suits laufen lasse</li>
									<li>
										Wäre PHP also in Rust geschrieben, dann könnte es diese art von Fehlern nicht geben?
										<ul>
											<li>Krass</li>
											<li>Absolutes alleinstellungsmerkmal unter "System programming" sprachen.</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								thread safety ist auch so ne sache
								<ul>
									<li>Threading ist hart</li>
									<li>Rust ist die erste sprache, welche thread safety erzwingen kann</li>
								</ul>
							</li>
							<li>
								Wie macht rust das alles?
								<ul>
									<li>Es kompilliert schlicht nicht, wenn es sich nicht sicher ist.</li>
								</ul>
							</li>
							<li>
								man muss verstehen, dass rust primär aus einem grund entwickelt wurde
								<ul>
									<li>große codebases maintainbar zu halten. ohne jegliche performancekosten.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>



				<section data-background-video="img/gKLWZjBu2iQ.webm">
					<img  style="opacity: 0.5" src="img/cartoon_c.png" />
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
						<a href="https://www.youtube.com/watch?v=gKLWZjBu2iQ">youtube.com/gKLWZjBu2iQ</a>
					</small>
					<aside class="notes">
						<ul>

							<li>programmiert man C fühlt sich das für mich jedenfalls oft so an.</li>
							<li>... man kommt vorran</li>
							<li>ggf. aber auch nicht, es schmerzt.</li>
							<li>... immer diese ungewissheit, ob man sich nicht doch ins bein geschossen hat.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/cartoon_rust.png" style="max-width: 30%"/>
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
					</small>
					<aside class="notes">
						<ul>

							<li>rust ist völlig konträr</li>
							<li>ich hab dazu mal ein quote</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/fearless_in_rust.png">
					<aside class="notes">
						<ul>
							<li>rust ist völlig konträr</li>
							<li>ich hab dazu mal ein quote</li>
							<li>
								<ul>
									<li>ich kann das super nachvollziehen</li>
									<li>... wie macht rust das?</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				{#
				<section>
					<img src="img/rust_spoils_me2.png" style="max-width: 70%"/>
					<br/>
					<small>
						<a href="https://twitter.com/gilescope/status/992309474881822720">twitter.com</a>
					</small>

				</section>
				#}

				{#
				<section>
					<h3>das tolle an Rust, sind dessen Einschränkungen.</h3>
					<aside class="notes">
						<ul>

							<li>hört sich paradox an. wenn man drüber nachdenkt ergeben sich aus einschränkungen aber idr. Möglichkeiten.</li>
							<li></li>
						</ul>
					</aside>
				</section>
				#}

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(name);
}
					{% endblock %}

					{% endembed %}

					<aside class="notes">
						<ul>
							<li>Beispiel von eben.</li>
							<li><span style="font-style: italic">greet kopieren.</span></li>
							<li>Wer kennt eine sprache in der das problematisch wäre?</li>
							<li>
								jemand eine idee warum rust das verbietet?
								<ul>
									<li></li>
								</ul>
							</li>
							<li>jemand eine idee wie man das fixen könnte?</li>
							<li>die einfachste variante wäre den String wieder zurückzugeben. Keine angst, geht auch eleganter</li>
							<li>string wieder zurückzugeben sieht doof aus, ist aber ultra performant, rust kann den code inlinen und quasi komplett entfernen.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/ownership_in_c.png"><br/>
					<aside class="notes">
						<ul>
							<li>Die Folie hab ich geklaut, hätte ich gerne verlinkt, link geht aber nicht mehr :)</li>
							<li>welche sprache ist das? - C natürlich</li>
							<li>wem von euch ist das problem klar?</li>
							<li>C und C++ haben grauenhafte methodensignaturen, weil sie idr. den RAM nicht selbst allocieren können.</li>
							<li>die frage ist immer wer das free() aufruft. in so kleinen anwendungen ist das kein Problem, ist man aber Mozilla, und hat millionen zeilen C++ code siehts übel aus.</li>
							<li>in c++ werden gerne smartpointer verwendet, bringen aber auchnachteile</li>
							<li>rust braucht dies hier nicht, ists unsicher, sagt der compiler schlicht nein. Performance ist besser als wenn man einen solchen smartpointer verwendet.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : &String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							<li>wir können eine Referenz übergeben.</li>
							<li>würden wir einen String übergeben. würde die Funktion diesen String besitzen. der Besitzer gibt den String wieder frei.</li>
							<li>Referenzen müssen nicht freigegeben werden. Irgendwo muss ja ein besitzer sein, und dieser wird diesen garantiert freigeben.</li>
							<li>in der theorie ganz einfach, in der praxis schwierig :)</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : &str) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug";
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							<li>so könnten wir unseren String ausleihen.</li>
							<li>wenn man ihn leiht, gibt man ihn nicht wieder frei. man kann sich sicher sein, es gibt einen owner.</li>
							<li>
								weitere einschränkungen
								<ul>
									<li>es muss einen owner geben. jemand muss ihn freigeben.</li>
									<li>du kannst mehrfach von einer referenz lesen, aber nicht lesen uns schreiben :)</li>
								</ul>
							</li>
							<li>beispiel klar?</li>
							<li>warum nicht &String</li>
						</ul>
					</aside>
				</section>

				{#
				<section>
					<h1>&String vs &str</h1>
					<aside class="notes">
						<ul>
							<li>jemand ne idee wo der unterschied sein könnte?</li>
							<li>String ist Heap allociert, kann daher auch wachen.</li>
							<li>ein &str ist nur eine Zeichenkette von UTF8 Zeichen.</li>
							<li>das ist eine der ganz wenigen stellen wo rust irgendwas automatisch macht</li>
							<li>deref trait kann man auch selbst implementieren</li>
							<li>interessant für irgendwelche "fat pointer"</li>
						</ul>
					</aside>
				</section>
				#}

				<section>
					<small>
						<a href="https://rustup.rs">https://rustup.rs</a>
					</small>
					<br/>
					<img src="img/rustup.png" style="max-width: 50%">
				</section>

				<section>
					<img src="img/cargo_new_project.png">
					<aside class="notes">
						<ul>
							<li>cargo new legt euch ein neues projekt an</li>
							<li>--bin steht für binary, ohne wäre es eine statische lib.</li>
							<li>er initialisiert euch auch gleich ein git repo mit passender .gitignore</li>
							<li>cargo run baut das projekt und lässt es im debug mode laufen.</li>
							<li>cargo kümmert sich auch ums dependencymanagement.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>cargo</h2>
					<p>
						Cargo.toml / Cargo.lock
					</p>
					<img src="img/cargo_toml.png">
					<aside class="notes">
						<ul>
							<li>kein GOPATH oder sowas. Semver, lockfiles u.s.w.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>intellij</h2>
					<img src="img/intelli_rust.png">
					<aside class="notes">
						<ul>
							<li>support ist erschreckend gut. selbst macros etc.</li>
							<li>externe bibliotheken etc sind kein problem.</li>
							<li>rust ist in rust geschrieben, könnt also fast überall rein schauen.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>RLS</h2>
					<img src="img/rust_language_server.jpg">
					<aside class="notes">
						<ul>
							<li>Rust kommt mit einem language server, funktioniert wie z.b. bei typeskript und hat daher guten support für visual stio code</li>
							<li>Compiler selbst gibt cutocompletion etc. funktioniert sehr gut und wird immer besser.</li>
							<li>refactorings direkt im compiler, stimmen immer! :)</li>
							<li>intelli rust nutzt den language server nicht.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/run_rust_everywhere.png" style="max-width:60%" />
					<aside class="notes">
						<ul>
							<li>Rust hat keine runtime und ist daher quasi überall einsetzbar.</li>
							<li>graalvm ist serh interessant</li>
							<li>rust lässt sich auch von C aus callen, daher quasi überall einsetzbar</li>
							<li>webassemly ist auch sehr interessant. nicht nur fürs web. -> später ggf. mehr</li>
							<li>Graalvm ist für euch sicher interessant</li>
							<li>Graalvm lässt sich in C embedden, daher bestimmt auch in rust</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>namespaces / finding classes</h2>
					<aside class="notes">
						<ul>
							<li>erzähl nicht viel drüber</li>
							<li>streife das nur, weil ich es in GO ganz drauenhaft finde</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
                    {% endblock %}
					{% block php %}
 ├── client.rs
 └── network.rs
     └── server.rs

					{% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>

						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
// github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs

#[cfg(feature = "postgres")]
#[macro_use]
extern crate bitflags;
extern crate byteorder;
// This is required to make `diesel_derives` re-export, but clippy thinks its unused
#[cfg_attr(feature = "clippy", allow(useless_attribute))]
#[allow(unused_imports)]
#[macro_use]
extern crate diesel_derives;
#[doc(hidden)]
pub use diesel_derives::*;

#[macro_use]
mod macros;

#[cfg(test)]
#[macro_use]
extern crate cfg_if;

#[cfg(test)]
pub mod test_helpers;

pub mod associations;
pub mod backend;
pub mod connection;
pub mod data_types;
pub mod deserialize;
#[macro_use]
pub mod expression;
pub mod expression_methods;
#[doc(hidden)]
pub mod insertable;
pub mod query_builder;
pub mod query_dsl;
pub mod query_source;
#[cfg(feature = "r2d2")]
pub mod r2d2;
pub mod result;
pub mod serialize;
#[macro_use]
pub mod sql_types;
pub mod migration;
pub mod row;
pub mod types;

#[cfg(feature = "mysql")]
pub mod mysql;
#[cfg(feature = "postgres")]
pub mod pg;
#[cfg(feature = "sqlite")]
pub mod sqlite;

mod type_impls;
mod util;

pub mod dsl {
    //! Includes various helper types and bare functions which are named too
    //! generically to be included in prelude, but are often used when using Diesel.

    #[doc(inline)]
    pub use helper_types::*;

    #[doc(inline)]
    pub use expression::dsl::*;

    #[doc(inline)]
    pub use query_builder::functions::{delete, insert_into, insert_or_ignore_into, replace_into,
                                       select, sql_query, update};
}

pub mod helper_types {
    //! Provide helper types for concisely writing the return type of functions.
    //! As with iterators, it is unfortunately difficult to return a partially
    //! constructed query without exposing the exact implementation of the
    //! function. Without higher kinded types, these various DSLs can't be
    //! combined into a single trait for boxing purposes.
    //!
    //! All types here are in the form `<FirstType as
    //! DslName<OtherTypes>>::Output`. So the return type of
    //! `users.filter(first_name.eq("John")).order(last_name.asc()).limit(10)` would
    //! be `Limit<Order<FindBy<users, first_name, &str>, Asc<last_name>>>`
    use super::query_builder::locking_clause as lock;
    use super::query_dsl::methods::*;
    use super::query_dsl::*;
    use super::query_source::joins;

    #[doc(inline)]
    pub use expression::helper_types::*;

    /// Represents the return type of `.select(selection)`
    pub type Select<Source, Selection> = <Source as SelectDsl<Selection>>::Output;

    /// Represents the return type of `.filter(predicate)`
    pub type Filter<Source, Predicate> = <Source as FilterDsl<Predicate>>::Output;

    /// Represents the return type of `.filter(lhs.eq(rhs))`
    pub type FindBy<Source, Column, Value> = Filter<Source, Eq<Column, Value>>;

    /// Represents the return type of `.for_update()`
    #[cfg(feature = "with-deprecated")]
    #[allow(deprecated)]
    pub type ForUpdate<Source> = <Source as ForUpdateDsl>::Output;

    /// Represents the return type of `.for_update()`
    #[cfg(not(feature = "with-deprecated"))]
    pub type ForUpdate<Source> = <Source as LockingDsl<lock::ForUpdate>>::Output;

    /// Represents the return type of `.for_no_key_update()`
    pub type ForNoKeyUpdate<Source> = <Source as LockingDsl<lock::ForNoKeyUpdate>>::Output;

    /// Represents the return type of `.for_share()`
    pub type ForShare<Source> = <Source as LockingDsl<lock::ForShare>>::Output;

    /// Represents the return type of `.for_key_share()`
    pub type ForKeyShare<Source> = <Source as LockingDsl<lock::ForKeyShare>>::Output;

    /// Represents the return type of `.skip_locked()`
    pub type SkipLocked<Source> = <Source as ModifyLockDsl<lock::SkipLocked>>::Output;

    /// Represents the return type of `.no_wait()`
    pub type NoWait<Source> = <Source as ModifyLockDsl<lock::NoWait>>::Output;

    /// Represents the return type of `.find(pk)`
    pub type Find<Source, PK> = <Source as FindDsl<PK>>::Output;

    /// Represents the return type of `.or_filter(predicate)`
    pub type OrFilter<Source, Predicate> = <Source as OrFilterDsl<Predicate>>::Output;

    /// Represents the return type of `.order(ordering)`
    pub type Order<Source, Ordering> = <Source as OrderDsl<Ordering>>::Output;

    /// Represents the return type of `.then_order_by(ordering)`
    pub type ThenOrderBy<Source, Ordering> = <Source as ThenOrderDsl<Ordering>>::Output;

    /// Represents the return type of `.limit()`
    pub type Limit<Source> = <Source as LimitDsl>::Output;

    /// Represents the return type of `.offset()`
    pub type Offset<Source> = <Source as OffsetDsl>::Output;

    /// Represents the return type of `.inner_join(rhs)`
    pub type InnerJoin<Source, Rhs> =
        <Source as JoinWithImplicitOnClause<Rhs, joins::Inner>>::Output;

    /// Represents the return type of `.left_join(rhs)`
    pub type LeftJoin<Source, Rhs> =
        <Source as JoinWithImplicitOnClause<Rhs, joins::LeftOuter>>::Output;

    use super::associations::HasTable;
    use super::query_builder::{AsChangeset, IntoUpdateTarget, UpdateStatement};
    /// Represents the return type of `update(lhs).set(rhs)`
    pub type Update<Target, Changes> = UpdateStatement<
        <Target as HasTable>::Table,
        <Target as IntoUpdateTarget>::WhereClause,
        <Changes as AsChangeset>::Changeset,
    >;

    /// Represents the return type of `.into_boxed::<'a, DB>()`
    pub type IntoBoxed<'a, Source, DB> = <Source as BoxedDsl<'a, DB>>::Output;

    /// Represents the return type of `.distinct()`
    pub type Distinct<Source> = <Source as DistinctDsl>::Output;

    /// Represents the return type of `.distinct_on(expr)`
    #[cfg(feature = "postgres")]
    pub type DistinctOn<Source, Expr> = <Source as DistinctOnDsl<Expr>>::Output;

    /// Represents the return type of `.single_value()`
    pub type SingleValue<Source> = <Source as SingleValueDsl>::Output;
}

pub mod prelude {
    //! Re-exports important traits and types. Meant to be glob imported when using Diesel.
    pub use associations::{GroupedBy, Identifiable};
    pub use connection::Connection;
    #[deprecated(since = "1.1.0", note = "Explicitly `use diesel::deserialize::Queryable")]
    pub use deserialize::Queryable;
    pub use expression::{AppearsOnTable, BoxableExpression, Expression, IntoSql,
                         SelectableExpression};
    pub use expression_methods::*;
    #[doc(inline)]
    pub use insertable::Insertable;
    #[doc(hidden)]
    pub use query_dsl::GroupByDsl;
    pub use query_dsl::{BelongingToDsl, JoinOnDsl, QueryDsl, RunQueryDsl, SaveChangesDsl};

    pub use query_source::{Column, JoinTo, QuerySource, Table};
    pub use result::{ConnectionError, ConnectionResult, OptionalExtension, QueryResult};

    #[cfg(feature = "mysql")]
    pub use mysql::MysqlConnection;
    #[cfg(feature = "postgres")]
    pub use pg::PgConnection;
    #[cfg(feature = "sqlite")]
    pub use sqlite::SqliteConnection;
}

pub use prelude::*;
#[doc(inline)]
pub use query_builder::debug_query;
#[doc(inline)]
pub use query_builder::functions::{delete, insert_into, insert_or_ignore_into, replace_into,
                                   select, sql_query, update};
pub use result::Error::NotFound;
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>größeres Beispiel wie man sowas dann verwenden kann</li>
							<li>mit extern crate importieren wir bibliotheken (cargo.toml)</li>
							<li>mit mod inkludieren wir module.</li>
							<li>
								mit diesen pub mod, pub use konstrukten reoxportieren wir module
								<ul>
									<li>komplexe bibliothek</li>
									<li>einfache API wie man diese nutzen kann.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>tests</h2>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub fn add_two(a: i32) -> i32 {
	a + 2
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn it_works() {
		assert_eq!(4, add_two(2));
	}
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>cargo doc generiert api docs</li>
							<li>beste api docs die ich kenne (mit suchfunktion)</li>
							<li>code beispiele werden als tests ausgeführt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/documentation_tests.png" style="max-width: 60%"/>
				</section>

				<section>
					<h3>Lets use a webserver</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
#![feature(plugin)]
#![plugin(rocket_codegen)]

extern crate rocket;

#[get("/")]
fn index() -> &'static str {
	"Hello, world!"
}

fn main() {
	rocket::ignite().mount("/", routes![index]).launch();
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>gutes beispiel, sieht nicht so "low level" aus?</li>
							<li></li>
						</ul>
					</aside>
				</section>

				{#
				<section>
					<img src="img/rust_more_control_more_safety.png">
					<aside class="notes">
						<ul>
							<li>rust fühlt sich von den sprachkonstrukten nicht so low level an</li>
							<li>oft musst man bei sprachen zwischen controller und sicherheit wählen, rust versucht hier beides zu bieten.</li>
							<li>es dreht sich hier nur um controller / sicherheit.</li>
						</ul>
					</aside>
				</section>
				#}

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let a;

	if true {
		a = "Ja";
	} else {
		a = "Nein";
	}

	println!("{}", a);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>etliche variationen (unitialisiert / if return value))</li>
							<li>Rust -> safe</li>
						</ul>
					</aside>
				</section>

				<section>
					 {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let foo = "bar";
	foo = "bar2";


	println!("{}", foo);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>immutable by default</li>
							<li>am anfang dacht ich wils schöner ist</li>
							<li>performance + garantien bei multithreading</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let sum = {
		let a = 1;
		let b = 2;

		a + b
	};

	println!("{}", sum);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>beliebige scopes</li>
							<li>letzte expression wird zurück gegeben</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let names = vec![
		"Foo",
		"Bar",
	];

	println!("{}", names.join(", "));
}


                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						einfache arrays ...
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let mut names = vec![];
	names.push("Foo");
	names.push("Bar");

	println!("{}", names.join(", "));
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						arrays sind "veränderbar" nicht so wie bei c


						Compiler Warnung bei:

						fn main() {

						let mut names = Vec::new();

						println!("{}", names.join(", "));
						}
					</aside>
				</section>

				<section>


					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> String {
	reqwest::get("https://www.rust-lang.org")
		.unwrap()
		.text()
		.unwrap()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>unwrap bedeuet quasi gebe mir den wert, wenn nicht vorhanden töte das prog.</li>
							<li>unwrap ist safe, prog. ist ja danach aus. </li>
							<li>am anfang hat man unwraps, dann optimiert man diese alle weg</li>
							<li>kein unwrap = prog. läuft.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, String> {
	match reqwest::get("https://www.rust-lang.org") {
		Err(_) => Err("could not fetch www.rust-lang.org".to_string()),
		Ok(ref mut response) => {
			match response.text() {
				Err(_) => Err("could not decode text".to_string()),
				Ok(text) => Ok(text)
			}
		}
	}
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>rust unterstützt pattern matching</li>
							<li>
								man kann fast alles matchen
								<ul>
									<li>enums</li>
									<li>structs in structs</li>
									<li>tuple</li>
									<li>beliebig geschaftelt</li>
									<li>teile von structs</li>
									<li>referenzen auf teile von structs...</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, reqwest::Error> {
	try!(reqwest::get("https://www.rust-lang.org")).text()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>try! durch ein ? ersetzen</li>
							<li>ein return in einem macro returnt raus</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn foo1() -> Result<String, ()> {
	Err(())
}

pub fn foo2() -> Result<String, ()> {
	Ok(foo1()?.trim().to_string())
}

pub fn main() {
	println!("{:#?}", foo2());
}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>weiteres beispiel</li>
							<li>rust hat kein exception handling</li>
							<li>führt dazu, dass man jederzeit jeden fehler handhaben muss</li>
							<li>es gibt crates welches error handling sehr einfach machen, traces etc.</li>
						</ul>
					</aside>
				</section>



				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
use std::num::ParseIntError;

fn multiply(first_number_str: &str, second_number_str: &str)
	-> Result<i32, ParseIntError> {
    let first_number = first_number_str.parse::<i32>()?;
    let second_number = second_number_str.parse::<i32>()?;

    Ok(first_number * second_number)
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n)  => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}

					{% endblock %}

					{% endembed %}

					<aside class="notes">
						<ul>
							<li>etwas komplexeresbeispiel</li>
							<li>parsen kann fehlschlagen</li>
							<li>Result ist ein Enum, d.h. wir können auch drauf matchen.</li>
						</ul>
					</aside>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}

fn double_first(argv: Vec<&str>) -> Result<i32, String> {
    argv
        .iter()
        .nth(0)
        .ok_or("first argument not found".to_owned())
        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    println!("{:#?}", double_first(vec!["2"]));
}
					{% endblock %}

					{% endembed %}
						<aside class="notes">
						<ul>
							<li>die enums Result und Option bringen viele hilfsunktionen mit</li>
							<li>errorhandling ist ergonomisch</li>
						</ul>
					</aside>
				</section>


				<section>
					<h2>basic functional stuff</h2>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn main() {
	let numbers = vec![1, 2, 3, 4, 5, 6, 10, 100];

	let result: Vec<_> = numbers.iter()
	.filter(|&x| *x < 4)
	.filter(|&x| *x > 100)
	.map(|x| x * 2)
	.chain(10..11)
	.collect();

	println!("{:#?}", result);
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>typischer rust code, etwas funktional.</li>
						</ul>
					</aside>
				</section>


				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn do_greet(p : fn() -> String) {
	println!("hello {}", &p());
}

pub fn main() {
	do_greet(||{ "rheinjug".to_string() });
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>function pointer sind in rust Typen.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn do_greet<T>(p : T) where T : Fn() -> String  {
	println!("hello {}", &p());
}

pub fn main() {
	do_greet(||{ "rheinjug".to_string() });
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>wir können das ganze aber auch generisch formulieren.</li>
						</ul>
					</aside>
				</section>

				<section>
					<a target="_blank" href="https://doc.rust-lang.org/std/ops/index.html#traits">
						<img src="img/rust_fn_traits.png"/>
					</a>
				</section>
				<section>
					<a target="_blank" href="https://stackoverflow.com/a/30232500/2541932">
						<img src="img/rust_fn_trait2.png"/>
					</a>
				</section>

{#
				<section>
					<h2>Generics</h2>
					<aside class="notes">
						<ul>
							<li>wir haben ja grade schon generics gesehen, hier noch nen paar beispiele</li>
						</ul>
					</aside>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
enum May<T> {
	Value(T),
	Empty
}

impl<T> May<T> {
	pub fn unwrap(&self) -> &T {
		match self {
			&May::Value(ref v) => v,
			&May::Empty => panic!("yolo")
		}
	}
}

fn main() {
	println!("{}", May::Value::<i32>(10).unwrap());
	println!("{}", (May::Empty::<i32>).unwrap());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>So in der art ist option implementiert.</li>
						</ul>
					</aside>
				</section>
#}
				<section>
					<h3>Traits #2</h3>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
trait Greetable {
	fn greet(&self);
}

struct Person;

impl Greetable for Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() {
	Person{}.greet();
}
                    {% endblock %}
					{% block php %}
// kotlin
interface Greetable {
    fun greet();
}

class Person : Greetable {
    override fun greet() {
        println("hello :)");
    }
}

fun main(args: Array<String>) {
    val person : Greetable = Person();
    person.greet();
}

					{% endblock %}
					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}

fn do_greet<T>(p : T) where T : Fn() -> String {
	println!("hello {}", &p());
}

pub fn main() {
	do_greet(||{ "rheinjug".to_string() });
}

                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>Beispiel hatten wir eben schonmal.</li>
							<li>wir implementieren eine generische funktion welche T bekommt, wobei T einen trait implementiert, dass dieser zur Funktion gehört.</li>
							<li>wie wäre es, wenn wir ein Trait für ein Trait implementieren?</li>
						</ul>
					</aside>
				</section>
				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
trait Greetable {
	fn greet(&self);
}

impl<T> Greetable for T where T: Fn() -> String {
	fn greet(&self) {
		println!("Hello {}", self());
	}
}

pub fn main() {
	(||{ "rheinjug".to_string() }).greet();
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>hier implementieren wir Greetable für alle Funktionen, welche einen String zurückgeben.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
trait Greetable {
	fn greet(&self);
}

impl<T, X> Greetable for T
	where T: Fn() -> X,
	X : Fn() -> String
{
	fn greet(&self) {
		println!("Hello {}", self()());
	}
}

pub fn main() {
	(||{(||{ "rheinjug".to_string() })}).greet();
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>Solche Konstrukte lassen sich auch noch erweitern.</li>
							<li>abstrakte typen u.s.w.</li>
							<li>man kann auch sagen T muss dieses und jenes trait implementieren</li>
							<li>man kann auch zusätzlich noch angeben, dass etwas mindest so lange verfügbar sein muss wie etwas anderes... später mehr</li>
						</ul>
					</aside>
				</section>


				<section>
					<h2>static vs dynamic dispatch</h2>
					<aside class="notes">
						<ul>
							<li>wer kennt den untschied?</li>
							<li>welches ist schneller?</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person {
	age: i32
}

fn main() {
}
                    {% endblock %}
					{% block html %}
						<img src="img/static_dispatch1.png">
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>person hat wirklich nur die größe von age, und es ist ganz klar, wo age im speicher liegt</li>
						</ul>
					</aside>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person {
	age: i32
}

impl Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() {
	Person{ age: 10 }.greet();
}
                    {% endblock %}
					{% block html %}
						<img src="img/static_dispatch2.png">
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>der compiler weiß genau, wo der code liegt.</li>
							<li>let p = Person {age:12}; Person::greet(&p);</li>
						</ul>
					</aside>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

impl Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn greet(p : &Person) {
	p.greet()
}

fn main() { }
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>wenn wir nun eine greet funktion haben, weiß der compiler es noch immer ganz genau</li>
						</ul>
					</aside>
				</section>
				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
    fn greet(&self);
}

impl Greetable for Person {
    fn greet(&self) {
        println!("hello :)");
    }
}

fn greet(p : &Greetable) {
	p.greet();
}

fn main() { greet(&Person{}); }
                    {% endblock %}
					{% block html %}
					<img src="img/static_dispatch3.png">
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>wie schaut es hier aus?</li>
							<li>der compiler weiß idr. nur noch, dass er ein greetable bekommt</li>
							<li>das sind sogenante trait objekte.</li>
							<li>in diesem fall wird eine vtable (i.d.r.) benötigt.</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
	fn greet();
}

impl<T> Person
	where T: Greetable
{
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() { }
                    {% endblock %}
					{% endembed %}
						<aside class="notes">
						<ul>
							<li>wenn wir das ganze generisch formulieren, haben wir auch ein static dispatch</li>
							<li>warum? funktion wird kopiert ...</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>comparing asm</h2>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
    fn greet(&self);
}

impl Greetable for Person {
    fn greet(&self) {
        println!("hello :)");
    }
}

fn hello<T>(v : &T) where T : Greetable {
    v.greet();
}

fn main() {
    hello(&Person{});
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    println!("hello :)");
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
    fn greet(&self);
}

impl Greetable for Person {
    fn greet(&self) {
        println!("hello :)");
    }
}

fn hello(v : &Greetable) {
    v.greet();
}

fn main() {
    hello(&Person{});
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
					<h2>returning trait objects.</h2>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub trait Greetable {}
pub struct Person;
impl Greetable for Person {}

pub fn return_greetable() -> Greetable {
    Person {}
}

pub fn main() {}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>funktioniert das?</li>
							<li>rust ist absolut statisch, ein trait kann nicht einfach zurück gegeben werden, weil die Size nicht bekannt ist.</li>
						</ul>


						<ul>
							<li>was können wir machen -> wir Boxen es. Dadurch ist es nur noch ein pointer.</li>
							<li>Box = Heap</li>
							<li>ein pointer hat eine size und einen destrukturor</li>
						</ul>
						... beispiel

						<ul>
							<li>nachteil: langsamer / dynaimic dispatch</li>
						</ul>

					</aside>

				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub trait Greetable {}
pub struct Person;
impl Greetable for Person {}

pub fn return_greetable<T>() -> T where T : Greetable {
    Person {}
}

pub fn main() {}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<li>was würde versuchen wenn wir das generisch formulieren wollten?</li>
						<li>uns fehlt hier T, code klappt also nicht.</li>
						<li>impl trait und nightly ...</li>
						<li>ipl trait ist static dispatch</li>
					</aside>

				</section>

<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub trait Greetable {}
pub struct Person1;
pub struct Person2;
impl Greetable for Person1 {}
impl Greetable for Person2 {}


pub fn return_greetable() -> impl Greetable {
    if true {
		Person1 {}
	} else {
		Person2 {}
	}
}

pub fn main() {}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<li>weil impl trait static dispatch garantiert, hat es ein paar einschränkungen ...</li>
						<li>wir können nur einen return type returnen</li>
						<li>... beispiel mit Box und dynamic dispatch ....</li>
					</aside>

				</section>


				<section>
					<h2>lifetime</h2>
				</section>


				<section>
					<img src="img/lifetime1.png"/>
				</section>
				<section>
					<img src="img/lifetime2.png"/>
				</section>
				<section>
					<img src="img/lifetime3.png"/>
				</section>
				<section>
					<img src="img/lifetime4.png"/>
				</section>
				<section>
					<img src="img/lifetime5.png"/>
				</section>
				<section>
					<img src="img/lifetime6.png"/>
				</section>
				<section>
					<img src="img/lifetime7.png"/>
				</section>
				<section>
					<img src="img/lifetime8.png"/>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo ".to_string();
    let foo_t = foo.trim();

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let mut foo = "foo ".to_string();
    let foo_t = foo.trim();

    foo = "bar".to_string();

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<li>trim funktion borgt sich lesend teile des strings</li>
						<li>da diese geborgt sind, können wir diese nicht verändern.</li>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let mut foo = "foo ";
    let foo_t = foo.trim();

    foo = "bar";

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>wer sieht den unterschied?</li>
							<li>gleicher code wie oben ohne die to_strings()</li>
							<li>wer kann erklären warum das nicht klappt?</li>
							<li>wer kann erklären warum das klappt?</li>
						</ul>
					</aside>
				</section>

				<section>
                    <img src="img/code_heap_stack.png" style="max-width:60%"/>
					<aside class="notes">
						<ul>
							<li>3 bereiche wo sich code aufhalten kann.</li>
							<li>einmal direkt in der binary</li>
							<li>im heap und im stack</li>
							<li>keine erklärung von heap und stack.</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo ";
}
                    {% endblock %}

					{% block html %}
					<img src="img/code_heap_stack.png"/>
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>wo landet der code?</li>
							<li>direkt embedded im code bereich.</li>
							<li>d.h. dieser string ist immer da. die lebenszeit ist unendlich</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo "
		.to_string();
}
                    {% endblock %}

					{% block html %}
					<img src="img/code_heap_stack.png"/>
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>lebenszeit?</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/nom_parser.png">
				</section>

				<section>
					<img src="img/nom_parser2.png">
				</section>


				<section>
					<h2>zero cost (functional example)</h2>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block php %}
fun main(args: Array<String>) {

    listOf(1, 2, 3)
        .map({ v -> println(v); });

}

// 1
// 2
// 3
					{% endblock %}

					{% endembed %}
				</section>

				<section>
					<img src="img/kotlin_map_function.png">
					<img src="img/kotlin_map_function2.png">
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    vec![1, 2, 3]
		.iter()
        .map(|x|{ println!("{}", x); });

}

					{% endblock %}

					{% endembed %}


					<aside class="notes">
						<pre>
							let x : () =
						</pre>
					</aside>

				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn map<B, F>(self, f: F) -> Map<Self, F> where
	Self: Sized, F: FnMut(Self::Item) -> B,
{
	Map{iter: self, f: f}
}

					{% endblock %}

					{% endembed %}

				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    [1, 2, 3]
		.iter()
        .map(|x|{ println!("{}", x); })
		.collect::<()>();

}

					{% endblock %}

					{% endembed %}

				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    for i in [1, 2, 3] {
		println!("{}", i);
	}

}

					{% endblock %}

					{% endembed %}

				</section>

				<section>
					<img src="img/map_is_identical.png"/>
				</section>

{#
				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
#[derive(Debug)]
struct Product {}

fn get_product(id : u32) -> Option<Product> {

    if id == 1 {
        return None;
    }

    if id == 2 {
        return None;
    }

    Some(Product {})
}

fn main() {
    println!("{:#?}", get_product(3));
}

					{% endblock %}

					{% block php %}
class Product {};
function get_product(int $id): ?Product {

	if ($id === 1) {
		return null;
	}

	if ($id === 2) {
		return null;
	}

	return new Product();

}
					{% endblock %}

					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
#[derive(Debug)]
struct Product {}

fn get_product(id : u32) -> Result<Option<Product>, ()> {

    if id == 1 {
        return Ok(None);
    }

    if id == 2 {
        return Err(());
    }

    Ok(Some(Product {}))
}

fn main() {
    println!("{:#?}", get_product(3));
}

					{% endblock %}

					{% endembed %}
				</section>

				<section>
					<img src="img/kotlin_operator1.png" />
					<img src="img/kotlin_operator2.png" />
					<aside class="notes">
							<ul>
								<li>? = elvis opetator</li>
								<li>!! = </li>
							</ul>
					</aside>
				</section>

#}

				<section>
					self consuming (&self vs self)
					<aside class="notes">
						<pre>
							wir hatten vorhin ja schon das self in parametern gesehen
						</pre>
					</aside>
				</section>

				<section>
					<h5>recap</h5>

					<p class="fragment" data-fragment-index="0">fn foo() {}</p>
					<p class="fragment" data-fragment-index="1">fn foo(&self) {}</p>
					<p class="fragment" data-fragment-index="2">fn foo(&mut self) {}</p>
					<p class="fragment" data-fragment-index="3">fn foo(self) {}</p>
					<p class="fragment" data-fragment-index="4">fn foo(mut self) {}</p>
					<aside class="notes">
						<ul>
							<li>einfache funktion</li>
							<li>funktion bekommt self, readonly</li>
							<li>funktion bekommt self, mutable</li>
							<li>funktion konsumiert self</li>
							<li>funktion konsumiert self mutable</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
struct Person {pub name : String}
#[derive(Default)]
struct PersonBuilder{ name: Option<String> }

impl PersonBuilder {
    pub fn new() -> Self { PersonBuilder::default() }
    pub fn with_name(mut self, name : String) -> Self {
        self.name = Some(name);
        self
    }
    pub fn build(self) -> Person {
        Person { name: self.name.expect("...") }
    }
}

fn main() {
    let person_builder = PersonBuilder::new()
        .with_name("tim".to_string());

    let person = person_builder.build();

    println!("{}", person.name);
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
					<ul>
						<li>einfache factory für eine Person</li>
						<li>custom derives -> annotationen welche den ast verändern. implementieren traits.</li>
						<li>
							Beispiel, verwendung von personBuilder nach dem build aufruf. -> person_builder.with_name("bar".to_string());
						</li>
						<li>used of moved value -> wert wird nur gemoved, builder ist zero overhead</li>
					</ul>
				</aside>
			</section>

				<section>
					<img src="img/maven_central.png"/>
				</section>
				<section>
					<img src="img/packagist_stats.png"/>
				</section>
				<section>
					<img src="img/crates_io.png"/>
				</section>
				<section>
					<img src="img/yew.png"/>
				</section>
				<section>
					<img src="img/web_view.png"/>
				</section>
				<section>
					<img src="img/redox.png"/>
				</section>
				<section>
					<img src="img/servo.png"/>
				</section>
				<section>
					<img src="img/rocket_rs.png"/>
				</section>
				<section>
					<img src="img/rust_diesel.png"/>
				</section>
				<section>
					<img src="img/rust_diesel2.png"/>
				</section>
				<section>
					<img src="img/rust_git.png"/>
				</section>
				<section>
					<img src="img/graalvm.png"/>
				</section>
				<section>
					<img src="img/bindgen.png"/>
				</section>
				<section>
					<img src="img/writing_an_os.png"/>
				</section>
				<section>
					<img src="img/rust_by_example.png"/>
				</section>
				<section>
					<img src="img/rust_book.png"/>
				</section>
				<section>
					<img src="img/libc.png"/>
				</section>
				<section>
					<img src="img/futures_rs.png"/>
				</section>
				<section>
					<img src="img/hello_rust_show.png"/>
				</section>
				<section>
					<img src="img/rust_neon.png"/>
				</section>
				<section>
					<img src="img/rust_osnabrück.png"/>
				</section>
				<section>
					<img src="img/rust_emulator.png"/>
				</section>
				<section>
					<img src="img/rust_team.png" style="max-width: 25%"/>
				</section>

				<section>
					<img src="img/nebulet.png"/>
					<aside class="notes">
						<ul>
							<li>warum ist das cool?</li>
							<li>webassembly ist by design sandboxed</li>
							<li>syscalls brauchen atm z.b. einen kontextswitch</li>
							<li>bei webassembly wäre dies nicht notwendig...</li>
							<li>untrusted programs ....</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>bonus: lifetime</h2>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
struct Person {
    name: String
}

fn main() {
    let name = "tim";

    let p = Person {
        name: name.to_string()
    };
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>eigentlich schade, tim liegt ja schon im ram.</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
struct Person<'a> {
    name: &'a str
}

fn main() {
    let name = "tim";

    let p = Person { name };
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>eigentlich schade, tim liegt ja schon im ram.</li>
							<li>wir sagen der parameter lebt wenigstens so lang, wie das struct</li>
							<li>der name apostroph a ist egal, es ist mehr wie eine gleichung.</li>
							<li>stack wird umgekehr freigegeben, daher klappt der code, erst p dann name</li>
							<li>drop einbauen.</li>
							<li>warum klappts noch immer?</li>
						</ul>
					</aside>
				</section>
				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
struct Person<'a> {
    name: &'a str
}

fn main() {
    let name = "tim".to_string();

    let p = Person { name: &name };

    drop(name)
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>
								das ganze funktioniert in beliebig tiefen strukturen, wird aber recht schnell sehr kompliziert
							</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>threading</h2>
				</section>

				<section>
					  {% embed "twig/editor.html.twig" %}

					{% block rust %}
use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
					{% endblock %}

					{% endembed %}

					<aside class="notes">
						<ul>
							<li>etwas komplexeres Beispiel</li>
							<li>ein Owner kann ein Struct oder eine Funktion sein</li>
							<li>in diesem Fall (syntax für lambda) wird eine Lambda erstelt</li>
							<li>die lambda wird owner von data</li>
							<li>Data kann nur einen Owner haben -> womit dies nicht kompilliert</li>
						</ul>
					</aside>

				</section>

				<section>
				  {% embed "twig/editor.html.twig" %}

					{% block rust %}
use std::thread;
use std::time::Duration;

fn main() {
    let data = vec![1, 2, 3];

    for i in 0..3 {

        let mut x = data[i].clone();

        thread::spawn(move || {
            x += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>ein Quick Fix wäre einfach die daten zu kopieren</li>
							<li>dies ist nun threadsafe weil x in die lambda gemoved werden kann</li>
							<li>doof nur, dass man diese ja dann nicht mehr ausgeben kann</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}

					{% block rust %}
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>Um das wirklicj zu fixen brauchen wir sowas wie einen Mutex</li>
							<li>Dieser hebelt mit sogenannten unsafe code den borrow checker aus</li>
							<li>Der mutex selbst ist also in Rust geschrieben</li>
							<li>Wir beschäftigen uns heute nicht damit wie dieser intern funktioniert</li>
							<li>wichtig ist, es ist total safe diesen zu nutzen.</li>
							<li>Fehler führen schlicht dazu, dass dies nicht kompilliert.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/ryon.png"/>
					<aside class="notes">
						<ul>
							<li>parallel iterator</li>
						</ul>
					</aside>
				</section>

<section>
					{% embed "twig/editor.html.twig" %}

					{% block rust %}
extern crate scoped_threadpool;
use scoped_threadpool::Pool;

fn main() {
    // Create a threadpool holding 4 threads
    let mut pool = Pool::new(4);

    let mut vec = vec![0, 1, 2, 3, 4, 5, 6, 7];

    pool.scoped(|scoped| {
        for e in &mut vec {
            scoped.execute(move || {
                *e += 1;
            });
        }
    });

    assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7, 8]);
}
					{% endblock %}

					{% endembed %}
					<aside class="notes">
						<ul>
							<li>threadpool welcher parallel arbeitet.</li>
							<li>garantiert safe.</li>
							<li>channels, reactor, promisses, asinc io, ...</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>bonus: how trim works</h2>
				</section>

				<section>
					<img src="img/trim1.png"/>
				</section>
				<section>
					<img src="img/trim2.png"/>
				</section>
				<section>
					<img src="img/trim3.png"/>
				</section>
				<section>
					<img src="img/trim4.png"/>
				</section>

				<section>
					<img src="img/last_slide.png"><br/>
					<a href="https://medium.com/@deckarep/paradigms-of-rust-for-the-go-developer">https://medium.com/@deckarep/paradigms-of-rust-for-the-go-developer</a>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                width: "100%",
                height: "100%",
                margin: 0,
                minScale: 1,
                maxScale: 1,
                history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
