<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/idea.css">

		<script src="jquery-3.0.0.min.js"></script>

		<style>
			iframe {
				max-width: 100% !important;
			}

			pre {
				box-shadow: none !important;
			}

			.right-code {
				border-left: 1px solid silver !important;
			}

			section img {
				border: 1px solid #ccc !important;
			}

			.editor img {
				max-width: 50%;
				border: 0 !important;
				box-shadow: none !important;
			}

			.reveal pre code {
				max-height: inherit !important;
			}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<script type="application/javascript">
            $(document).ready(function() {
                $('.editor').each(function (i, v) {

                    $(v).css({
                        'height': $(document).height() - 100,
                        'border': '1px solid silver',
                        'display': 'flex',
                        'justify-content': 'flex-start'
                    });

                    let rust_pen = "http://127.0.0.1:5000";
                    //var rust_pen = "https://play.rust-lang.org/";

                    let rust_code = $(v).data('code-rust');


                    $(v).html('');


                    if (rust_code) {
                        $(v).append($('<iframe style="flex: 1 1 auto;overflow:scroll"/>').attr('src', rust_pen + '/?pageMode=presentation&code=' + encodeURIComponent(rust_code)));
                    }

					let php_code = $(v).data('code-php');
                    if (php_code && php_code.trim()) {
                        let php_code_node = $('<div class="right-code"><pre><code data-trim data-noescape class="code"></code></pre></div>');
						php_code_node.find('.code').text(php_code);
						$(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(php_code_node));
						return;
                    }

                    let html_code = $(v).data('code-html');
                    if (html_code && html_code.trim()) {
						$(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(html_code));
						return;
                    }

                });

                $('.editor > *').each(function(i, v) {
                    //$(v).css('margin', '10px');
                }).mouseenter(function(e) {
                    $(e.target).css('flex', '95 1 auto');
                    $(e.target).siblings().css('width', 100);
                    $(e.target).siblings().css('flex', '1 1 auto');
                })
                    .mouseleave(function(e) {
                        $(e.target).css('flex', '1 1 auto');
                        $(e.target).css('width', '');
                        $(e.target).siblings().css('width', '');
                    });
            });


		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    {% embed "twig/editor.html.twig" %}
                        {% block rust %}
// if you can't read this,
// take another seat.
fn main() {
	println!("hello rheinjug");
}
                        {% endblock %}

                        {% block php %}
// kotlin
fun main(args: Array<String>) {
	println("hello rheinjug");
}

// php
echo "hello rheinjug";
                        {% endblock %}
                    {% endembed %}
						<aside class="notes">
							<ul>
								<li>nimmt man 3 sprachen, so hat man 3 unterschiedliche implementierungen was strings angeht.</li>
								<li>in rust gibt es 4 string typen, klassische sind strings immer utf8 und mutable</li>
								<li>strings in kotlin sind nicht mutable und nutzen wie java utf-16,  das default defaultCharset ist allerdings utf8. es gibt im issue tracker eine diskussion auf utf-8 zu wechseln.</li>
								<li>strings in php sind byte sequenzen. php6 ist dran gecheitert.</li>
								<li>
									wenn ihr bei php genau guckt, mal hab ich das echo mit klammern geschrieben, mal ohne.
									das ist eine besonderhet in php, echo ist ein eigener opcode.
									schaut man auf die rust implementierung siehst man das ausrufezeichen. Dabei handelt es sich nicht um ein sprachkonstrukt, sondern um ein macro.
								</li>
							</ul>
						</aside>
				</section>

					<section>
						<img src="img/me.jpeg" style="max-width:200px"><br/>
						<i>@timglabisch</i>
						<br/>
						<img src="img/github_stats.png" style="max-width:370px"/>
						<aside class="notes">
							<ul>
								<li>Ich bin Tim</li>
								<li>Wer schonmal hier aus der UG war und nicht über mich hinweg gesehen hat, hat mich bestimmt schonmal gesehen</li>
								<li>
									... Und Github denkt ich würde in diesen Sprachen entwickeln
									<ul>
										<li>Das ist definitiv falsch, ich mach kein Basic x)</li>
										<li>und CSS ist dieser Talk ^^</li>
										<li>gibt aber vielleicht ein ganz guten Überblick über meinen "sprachlichen" Background</li>
									</ul>
								</li>
								<li>
									Ich arbeite für Easybill, platform zum rechnungen schreiben und mache primär PHP.
								</li>
								<li>
									Früher war ich viel als PHP Consult unterwegs.
								</li>
								<li>
									Hatte ja schon angekündigt, dass der Talk sehr codelastig wird.
									<ul>
										<li>Ich hab aber auch viele Slides mitgebracht</li>
										<li>Sollte ich euch deutlich zu schnell werden, einfach aufschreien oder mit irgendwas nach mir werfen.</li>
									</ul>
								</li>
							</ul>
						</aside>
					</section>

					<section>
						<h2>Basics</h2>
						<aside class="notes">
							<ul>
								<li>schauen wir uns basics an?</li>
								<li>was ist erstmal das wichtigste?</li>
								<li>schauen wir uns klassen an :)</li>
							</ul>
						</aside>
					</section>

				{#
					<section>
                        {% embed "twig/editor.html.twig" %}
                        {% block rust %}
fn main() {
	let a: &[u8] = b"hello, Rheinjug!";
	println!(
		"{}",
		::std::str::from_utf8(a)
			.expect("i am sure it's valid utf8")
	);
}
                        {% endblock %}

                        {% block php %}
// kotlin
import java.nio.charset.Charset

fun main(args: Array<String>) {
	val a = "Hello Rheinjug"
		.toByteArray(Charset.defaultCharset());
	println(
		String.format(
			"%s",
			a.toString(Charset.defaultCharset())
		)
	);
}

// php
echo(sprintf("%s", "Hello Rheinjug!"));

                        {% endblock %}
                    {% endembed %}


				</section>
#}
				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(name);
}
					{% endblock %}

					{% block php %}
// kotlin
private fun greet(name : String) {
	println("Hello " + name);
}

fun main(args: Array<String>) {
	val name = "Rheinjug";
	greet(name)
}

// php
function greet(string $name) {
	echo sprintf(
		"Hello %s", $name
	);
}

$name = "PHPUG";
greet($name);



					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>Hier sehen wir eine Funktion welche aufgerufen wird (greet)</li>
								<li>Typisierung der Funktion (String) ist steht auf der rechten seite Kotlin und Rust machen dies identisch. Java und PHP nicht.</li>
								<li>ich werde für den Moment noch nicht auf das .to_string() eingehen, vielleicht schaffen wir das gleich noch</li>
							</ul>
						</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	pub age: i32
}

pub fn main() {
	let tim = Person { age: 27 };
	println!(
		"tim is {} years old",
		tim.age
	);
}
					{% endblock %}

					{% block php %}
class Person(val age : Int);

fun main(args: Array<String>) {
	val tim = Person(25);
	println(
		"tim is " + tim.age + " years old"
	)
}

					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>In Rust definieren wir ein Strukt mit einer Property. in Kotlin eine Klasse.</li>
							<li>Strukts haben felder, Klassen haben properties</li>
							<li>
								Jede sprache hat eine andere ideologie. Sieht man z.b. daran:
								Kotlin ist public by default, Rust ist private by default.
								<ul>
									<li>Kotlin ist eher pragmatisch</li>
									<li>Rust versucht extrem korrekt und expliizit zu ein. werden wir noch öfters sehen.</li>
									<li>anderes beispiel, wir hatten eben da expect beim wandeln in utf8.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	age: i32
}

impl Person {
	pub fn new(age: i32) -> Self {
		Person {
			age
		}
	}

	pub fn get_age(&self) -> i32 {
		self.age
	}
}

pub fn main() {
	let tim = Person::new(25);
	println!("tim is {} years old", tim.get_age());
}
					{% endblock %}

					{% block php %}
class Person(private val age : Int) {
	fun getAge(): Int {
		return this.age;
	}
}

fun main(args: Array<String>) {
	val tim = Person(25);
	println(
		"tim is " + tim.getAge() + " years old"
	)
}


					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>hier das gleiche beipiel mit einem getter.</li>
								<li>
                                    hier sieht man deutliche unterschiede
                                    <ul>
                                        <li>Kotlin code ist weniger</li>
                                        <li>Rust kennt keinen Konstruktur, ist einfach eine statische methode, welche eine Instanz zurückgibt.</li>
										<li>Rust hat keine echten klassen, sieht mehr aus wie golang (impl für ein strukt)</li>
										<li>
											Rust trennt zustand (properties) von Funktionen.
											<ul>
												<li>mehrere impl blöcke pro strukt</li>
												<li>impl blöcke für andere structs</li>
											</ul>
										</li>
										<li>
											Rust nimmt speichermanagement extrem genau, sehen wir später noch.
											<ul>
												<li>
													in kotlin -> Person ist eine Instanz einer Klasse welche im Heap liegt.
												</li>
												<li>
													In Rust ist Person eine Datenstruktur der Größe Integer, welche auf dem Stack liegt. Kein Refcounting etc. Wer weiß, was refcounting ist? später mehr dazu.
												</li>
											</ul>
										</li>
                                    </ul>
                                </li>
							</ul>
						</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>

							<li>wenn man sich in projekten anguckt fühlt man sich mitlerweilse oft so.</li>
							<li>unsere technologielandschaft ähnelt in vielen Projekten oft eher einem Abenteuerspielplatz als einem enterprise projekt</li>

							<!--
							<li>
								da ganze hat 2 seiten
								<ul>
									<li>wir lernen grade software so zu implementieren, dass diese komponenten isoliert und wegwerfbar sind.</li>
									<li>software ist heute mehr wie eine PET-Flasche, man nuckelt dran und wirft ie weg.</li>
									<li>recruiting spielt da auch mit rein, viele wollen schlicht ausprobieren können.</li>
									<li>probiert man nicht aus, sammelt man keine erfahrung</li>
									<li>kunst liegt darin, gefahrlos auszuprobieren</li>
								</ul>
								<ul>
									<li></li>
								</ul>
							</li>
							-->

							<li>agile herangehensweisen machen es einfach mal was neues in ein projekt zu werfen, hype driven development ist gang und gebe</li>
							<li>die meisten entwickler haben mehr javascript frameworks selbst gebau, als das sie algorithmen implementieren können - so ist das eben heute, und ich finds auch nicht schlimm.</li>
							<li>in den letzten paar jahren ist die menge an technologien pro projekt extrem gestiegen, frameworks werden komplexer u.s.w.</li>
							<li>... und nun stelle ich euch mal wieder eine neue technologie vor, welche neue Hoffnung bringen soll. wie jede andere technologie mit der man sich rumschlägt.</li>

							<li>in dem talk möchte ich euch näher bringen, warum ich der meinung bin, dass rust nicht in dieses pattern fällt.</li>
							<li>-> schauen wir uns dazu mal die rust startseite an.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_lang_org_startpage1.png" />
					<aside class="notes">
						<aside class="notes">
							<ul>
								<li>Da schon wieder der Begriff system programming</li>
								<li>ist das kotlin auch? wohl eher web programming, mhhmm</li>
								<li>und rust will "schnell" sein</li>
								<li>ok, nichts neues, das sind C und C++ z.b. auch. und schnell ist ja eh relativ</li>
							</ul>
						</aside>
					</aside>
				</section>
					
				<section>
					<img src="img/system_prgramming_languages.png">
					<a href="https://en.wikipedia.org/wiki/System_programming_language">wikipedia.org/wiki/System_programming_language</a>
					<aside class="notes">
						<ul>
							<li>wikipedia listet 15 system programming languages</li>
							<li>das sind echt wenig sprachen, oder? wenn man mal danach schau, in welchen sprachen tatsächlich betriebsysteme / treiber geschrieben werden, wird die liste kürzer.</li>
							<li>ich bin ehrlich gesagt über swift gestolpert, weil es für mich keine wirkliche system programming language ist.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/swift_system_programming.png">
					<br/>
					<small>
						<a href="https://www.quora.com/Is-Swift-a-great-systems-programming-language">quora.com/Is-Swift-a-great-systems-programming-language</a>
					</small>
				</section>

				<section>
					<img src="img/language_ranking_with_tiobe.png">
					<aside class="notes">
						schaut man mal welche sprachen tatsächlich viel genutzt werden.
						das ist krass, C und C++ sind uralt und unter den ersten Plätzen.

					</aside>
				</section>


				<section>
					<img src="img/system_prgramming_languages_reduced.png">
					<aside class="notes">
						schaut man welche sprache heute tatsächlich noch relevanz haben, landet man meiner Meinung nach bei 3 Sprachen.
						Swift hatte ich raus genommen, weil ich es nicht als Konkurrent zu C / C++ sehe.

					</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>

							<li>nun sieht man, dass es in dem bereich garnicht soviel gibt.</li>
							<li>nun könnte man sagen, ich will garkein C und C++ lernen, wofür dann rust?</li>
							<li>die 31 Jahre zeigen wie schwer es ist.</li>
							<li>mozilla hat rund 6 jahre forschung in die reinen sprachkonzepte gesteckt.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/rust_lang_org_startpage2.png">
					<aside class="notes">
						<ul>
							<li>prevents segfaults - kennt jemand segfaults?</li>
							<li>
								ich programmiere viel php, da sieht man schonmal häufig segfaults. php ist in C geschrieben.
								<ul>
									<li>PHP Intern sind und kein spass zum Debuggen machen</li>
									<li>hab ich häufiger mal wenn ich gewaltige tests suits laufen lasse</li>
									<li>
										Wäre PHP also in Rust geschrieben, dann könnte es diese art von Fehlern nicht geben?
										<ul>
											<li>Krass</li>
											<li>Absolutes alleinstellungsmerkmal unter "System programming" sprachen.</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								thread safety ist auch so ne sache
								<ul>
									<li>Threading ist hart</li>
									<li>Rust ist die erste sprache, welche thread safety erzwingen kann</li>
								</ul>
							</li>
							<li>
								Wie macht rust das alles?
								<ul>
									<li>Es kompilliert schlicht nicht, wenn es sich nicht sicher ist.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>



				<section data-background-video="img/gKLWZjBu2iQ.webm">
					<img  style="opacity: 0.5" src="img/cartoon_c.png" />
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
						<a href="https://www.youtube.com/watch?v=gKLWZjBu2iQ">youtube.com/gKLWZjBu2iQ</a>
					</small>
					<aside class="notes">
						<ul>

							<li>...</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/cartoon_rust.png" style="max-width: 30%"/>
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
					</small>
					<aside class="notes">
						<ul>

							<li>nun sieht man, dass es in dem bereich garnicht soviel gibt.</li>
							<li>nun könnte man sagen, ich will garkein C und C++ lernen, wofür dann rust?</li>
							<li>die 31 Jahre zeigen wie schwer es ist.</li>
							<li>mozilla hat rund 6 jahre forschung in die reinen sprachkonzepte gesteckt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_spoils_me2.png" style="max-width: 70%"/>
					<br/>
					<small>
						<a href="https://twitter.com/gilescope/status/992309474881822720">twitter.com</a>
					</small>
				</section>

				<section>
					<h3>das tolle an Rust, sind dessen Einschränkungen.</h3>
					<aside class="notes">
						<ul>

							<li>hört sich paradox an. wenn man drüber nachdenkt ergeben sich aus einschränkungen aber idr. Möglichkeiten.</li>
							<li></li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(name);
}
					{% endblock %}

					{% block php %}
// kotlin
private fun greet(name : String) {
	println("Hello " + name);
}

fun main(args: Array<String>) {
	val name = "Rheinjug";
	greet(name)
}

// php
function greet(string $name) {
	echo sprintf(
	"Hello %s", $name
	);
}

$name = "PHPUG";
greet($name);

					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>Beispiel von eben.</li>
							<li><span style="font-style: italic">greet kopieren.</span></li>
							<li>Wer kennt eine sprache in der das problematisch wäre?</li>
							<li>
								jemand eine idee warum rust das verbietet?
								<ul>
									<li></li>
								</ul>
							</li>
							<li>jemand eine idee wie man das fixen könnte?</li>
							<li>die einfachste variante wäre den String wieder zurückzugeben. Keine angst, geht auch eleganter</li>
							<li>string wieder zurückzugeben sieht doof aus, ist aber ultra performant, rust kann den code inlinen und quasi komplett entfernen.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/ownership_in_c.png"><br/>
					<aside class="notes">
						<ul>
							<li>Die Folie hab ich geklaut, hätte ich gerne verlinkt, link geht aber nicht mehr :)</li>
							<li>welche sprache ist das? - C natürlich</li>
							<li>wem von euch ist das problem klar?</li>
							<li>C und C++ haben grauenhafte methodensignaturen, weil sie idr. den RAM nicht selbst allocieren können.</li>
							<li>die frage ist immer wer das free() aufruft. in so kleinen anwendungen ist das kein Problem, ist man aber Mozilla, und hat millionen zeilen C++ code siehts übel aus.</li>
							<li>in c++ werden gerne smartpointer verwendet, bringen aber auchnachteile</li>
							<li>rust braucht dies hier nicht, ists unsicher, sagt der compiler schlicht nein. Performance ist besser als wenn man einen solchen smartpointer verwendet.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : &String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							<li>wir können eine Referenz übergeben.</li>
							<li>würden wir einen String übergeben. würde die Funktion diesen String besitzen. der Besitzer gibt den String wieder frei.</li>
							<li>Referenzen müssen nicht freigegeben werden. Irgendwo muss ja ein besitzer sein, und dieser wird diesen garantiert freigeben.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
#![inline(always)]
pub fn greet(name : &str) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug";
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							</ul>
					</aside>
				</section>
					
				<section>
					<small>
						<a href="https://rustup.rs">https://rustup.rs</a>
					</small>
					<br/>
					<img src="img/rustup.png" style="max-width: 50%">
				</section>

				<section>
					<img src="img/cargo_new_project.png">
					<aside class="notes">
						<ul>
							<li>cargo new legt euch ein neues projekt an</li>
							<li>--bin steht für binary, ohne wäre es eine statische lib.</li>
							<li>er initialisiert euch auch gleich ein git repo mit passender .gitignore</li>
							<li>cargo run baut das projekt und lässt es im debug mode laufen.</li>
							<li>cargo kümmert sich auch ums dependencymanagement.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>cargo</h2>
					<p>
						Cargo.toml / Cargo.lock
					</p>
					<img src="img/cargo_toml.png">
					<aside class="notes">
						<ul>
							<li>kein GOPATH oder sowas. Semver, lockfiles u.s.w.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>intellij</h2>
					<img src="img/intelli_rust.png">
					<aside class="notes">
						<ul>
							<li>support ist erschreckend gut. selbst macros etc.</li>
							<li>externe bibliotheken etc sind kein problem.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>RLS</h2>
					<img src="img/rust_language_server.jpg">
					<aside class="notes">
						<ul>
							<li>Rust kommt mit einem language server, funktioniert wie z.b. bei typeskript und hat daher guten support für visual stio code</li>
							<li>Compiler selbst gibt outocompletion etc. funktioniert sehr gut und wird immer besser.</li>
							<li>refactorings direkt im compiler, stimmen immer! :)</li>
							<li>intelli rust nutzt den language server nicht.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>namespaces / finding classes</h2>
					todo
				</section>

				<section>
					<h3>Tests</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub fn add_two(a: i32) -> i32 {
	a + 2
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn it_works() {
		assert_eq!(4, add_two(2));
	}
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>cargo doc generiert api docs</li>
							<li>beste api docs die ich kenne (mit suchfunktion)</li>
							<li>api docs fürs ganze projekt</li>
							<li>code beispiele werden als tests ausgeführt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Lets write a webserver</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
#![feature(plugin)]
#![plugin(rocket_codegen)]

extern crate rocket;

#[get("/")]
fn index() -> &'static str {
	"Hello, world!"
}

fn main() {
	rocket::ignite().mount("/", routes![index]).launch();
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>gutes beispiel, sieht nicht so "low level" aus?</li>
							<li></li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_more_control_more_safety.png">
					<aside class="notes">
						<ul>
							<li>rust fühlt sich von den sprachkonstrukten nicht so low level an</li>
							<li>oft musst man bei sprachen zwischen controller und sicherheit wählen, rust versucht hier beides zu bieten.</li>
							<li>es dreht sich hier nur um controller / sicherheit.</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let a;

	if true {
		a = "Ja";
	} else {
		a = "Nein";
	}

	println!("{}", a);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						etliche variationen (unitialisiert / if return value))
						Rust -> safe
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let sum = {
		let a = 1;
		let b = 2;

		a + b
	};

	println!("{}", sum);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">

					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let names = vec![
		"Foo",
		"Bar",
	];

	println!("{}", names.join(", "));
}


                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						einfache arrays ...
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let mut names = vec![];
	names.push("Foo");
	names.push("Bar");

	println!("{}", names.join(", "));
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						arrays sind "veränderbar" nicht so wie bei c


						Compiler Warnung bei:

						fn main() {

						let mut names = Vec::new();

						println!("{}", names.join(", "));
						}
					</aside>
				</section>

				<section>


					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> String {
	reqwest::get("https://www.rust-lang.org")
		.unwrap()
		.text()
		.unwrap()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, String> {
	match reqwest::get("https://www.rust-lang.org") {
		Err(_) => Err("could not fetch www.rust-lang.org".to_string()),
		Ok(ref mut response) => {
			match response.text() {
				Err(_) => Err("could not decode text".to_string()),
				Ok(text) => Ok(text)
			}
		}
	}
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>


				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, String> {
	match reqwest::get("https://www.rust-lang.org") {
		Err(_) => Err("could not fetch www.rust-lang.org".to_string()),
		Ok(ref mut response) => {
			match response.text() {
				Err(_) => Err("could not decode text".to_string()),
				Ok(text) => Ok(text)
			}
		}
	}
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, reqwest::Error> {
	reqwest::get("https://www.rust-lang.org")?.text()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn foo1() -> Result<String, ()> {
	Err(())
}

pub fn foo2() -> Result<String, ()> {
	Ok(foo1()?.trim().to_string())
}

pub fn main() {
	println!("{:#?}", foo2());
}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>



				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
use std::num::ParseIntError;

fn multiply(first_number_str: &str, second_number_str: &str) -> Result<i32, ParseIntError> {
    let first_number = first_number_str.parse::<i32>()?;
    let second_number = second_number_str.parse::<i32>()?;

    Ok(first_number * second_number)
}

fn print(result: Result<i32, ParseIntError>) {
    match result {
        Ok(n)  => println!("n is {}", n),
        Err(e) => println!("Error: {}", e),
    }
}

fn main() {
    print(multiply("10", "2"));
    print(multiply("t", "2"));
}

					{% endblock %}

					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}

fn double_arg(argv: Vec<&str>) -> Result<i32, String> {
    argv
        .iter()
        .nth(0)
        .ok_or("Please give at least two arguments".to_owned())
        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(vec!["2"]) {
        Ok(n) => println!("{}", n),
        Err(err) => println!("Error: {}", err),
    }
}
					{% endblock %}

					{% endembed %}
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn main() {
	let numbers = vec![1, 2, 3, 4, 5, 6, 10, 100];

	let result: Vec<_> = numbers.iter()
	.filter(|&x| *x < 4)
	.filter(|&x| *x > 100)
	.map(|x| x * 2)
	.chain(10..11)
	.collect();

	println!("{:#?}", result);
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn do_greet(p : fn() -> String) {
	println!("hello {}", &p());
}

pub fn main() {
	do_greet(||{ "rheinjug".to_string() });
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>todo, wie nennt sich der syntax?</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Generics</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
enum May<T> {
	Value(T),
	Empty
}

impl<T> May<T> {
	pub fn unwrap(&self) -> &T {
		match self {
			&May::Value(ref v) => v,
			&May::Empty => panic!("yolo")
		}
	}
}

fn main() {
	println!("{}", May::Value::<i32>(10).unwrap());
	println!("{}", (May::Empty::<i32>).unwrap());
}
					{% endblock %}
					{% endembed %}
				</section>

				<section>
					<h3>Traits</h3>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
trait Greetable {
	fn greet(&self);
}

struct Person;

impl Greetable for Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() {
	Person{}.greet();
}
                    {% endblock %}
					{% block php %}
// kotlin
interface Greetable {
    fun greet();
}

class Person : Greetable {
    override fun greet() {
        println("hello :)");
    }
}

fun main(args: Array<String>) {
    val person : Greetable = Person();
    person.greet();
}

					{% endblock %}
					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}

fn do_greet<T>(p : T) where T : Fn() -> String {
	println!("hello {}", &p());
}

pub fn main() {
	do_greet(||{ "rheinjug".to_string() });
}

                    {% endblock %}
					{% endembed %}
				</section>
				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
trait Greetable {
	fn greet(&self);
}

impl<T> Greetable for T where T: Fn() -> String {
	fn greet(&self) {
		println!("Hello {}", self());
	}
}

pub fn main() {
	(||{ "rheinjug".to_string() }).greet();
}
					{% endblock %}
					{% endembed %}
				</section>
				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
trait Greetable {
	fn greet(&self);
}

impl<T, X> Greetable for T
	where T: Fn() -> X,
	X : Fn() -> String
{
	fn greet(&self) {
		println!("Hello {}", self()());
	}
}

pub fn main() {
	(||{(||{ "rheinjug".to_string() })}).greet();
}
					{% endblock %}
					{% endembed %}
				</section>


				<section>
					<h2>static vs dynamic dispatch</h2>
					<aside class="notes">
						<ul>
							<li>wer kennt den untschied?</li>
							<li>welches ist schneller?</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person {
	age: i32
}

fn main() {
}
                    {% endblock %}
					{% block html %}
						<img src="img/static_dispatch1.png">
					{% endblock %}
					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

impl Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() {
	Person{}.greet();
}
                    {% endblock %}
					{% block html %}
						<img src="img/static_dispatch2.png">
					{% endblock %}
					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

impl Person {
	fn greet(&self) {
		println!("hello :)");
	}
}

fn greet(p : &Person) {
	println!("hello :)");
}

fn main() { }
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
	fn greet();
}

impl<T> Person
	where T: Greetable
{
	fn greet(&self) {
		println!("hello :)");
	}
}

fn main() { }
                    {% endblock %}
					{% endembed %}
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
    fn greet(&self);
}

impl Greetable for Person {
    fn greet(&self) {
        println!("hello :)");
    }
}

fn hello<T>(v : &T) where T : Greetable {
    v.greet();
}

fn main() {
    hello(&Person{});
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    println!("hello :)");
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
struct Person;

trait Greetable {
    fn greet(&self);
}

impl Greetable for Person {
    fn greet(&self) {
        println!("hello :)");
    }
}

fn hello(v : &Greetable) {
    v.greet();
}

fn main() {
    hello(&Person{});
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
					<h2>lifetime</h2>
				</section>


				<section>
					<img src="img/lifetime1.png"/>
				</section>
				<section>
					<img src="img/lifetime2.png"/>
				</section>
				<section>
					<img src="img/lifetime3.png"/>
				</section>
				<section>
					<img src="img/lifetime4.png"/>
				</section>
				<section>
					<img src="img/lifetime5.png"/>
				</section>
				<section>
					<img src="img/lifetime6.png"/>
				</section>
				<section>
					<img src="img/lifetime7.png"/>
				</section>
				<section>
					<img src="img/lifetime8.png"/>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo ".to_string();
    let foo_t = foo.trim();

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo ".to_string();
    let foo_t = foo.trim();

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let mut foo = "foo ".to_string();
    let foo_t = foo.trim();

    foo = "bar".to_string();

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let mut foo = "foo ";
    let foo_t = foo;

    foo = "bar";

    println!("'{}'", &foo_t);
}
                    {% endblock %}
					{% endembed %}
				</section>

				<section>
                    <img src="img/code_heap_stack.png" style="max-width:60%"/>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo ";
}
                    {% endblock %}

					{% block html %}
					<img src="img/code_heap_stack.png"/>
					{% endblock %}

					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {
    let foo = "foo "
		.to_string();
}
                    {% endblock %}

					{% block html %}
					<img src="img/code_heap_stack.png"/>
					{% endblock %}

					{% endembed %}
				</section>

				<section>
					<h1>functional stuff</h1>
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block php %}
fun main(args: Array<String>) {

    listOf(1, 2, 3)
        .map({ v -> println(v); });

}

// 1
// 2
// 3
					{% endblock %}

					{% endembed %}
				</section>

				<section>
					<img src="img/kotlin_map_function.png">
					<img src="img/kotlin_map_function2.png">
				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    vec![1, 2, 3]
		.iter()
        .map(|x|{ println!("{}", x); });

}

					{% endblock %}

					{% endembed %}


					<aside class="notes">
						<pre>
							let x : () =
						</pre>
					</aside>

				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn map<B, F>(self, f: F) -> Map<Self, F> where
	Self: Sized, F: FnMut(Self::Item) -> B,
{
	Map{iter: self, f: f}
}

					{% endblock %}

					{% endembed %}

				</section>


				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    [1, 2, 3]
		.iter()
        .map(|x|{ println!("{}", x); })
		.collect::<()>();

}

					{% endblock %}

					{% endembed %}

				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
fn main() {

    for i in [1, 2, 3] {
		println!("{}", i);
	}

}

					{% endblock %}

					{% endembed %}

				</section>

				<section>
					<img src="img/map_is_identical.png"/>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
#[derive(Debug)]
struct Product {}

fn get_product(id : u32) -> Option<Product> {

    if id == 1 {
        return None;
    }

    if id == 2 {
        return None;
    }

    Some(Product {})
}

fn main() {
    println!("{:#?}", get_product(3));
}

					{% endblock %}

					{% block php %}
class Product {};
function get_product(int $id): ?Product {

	if ($id === 1) {
		return null;
	}

	if ($id === 2) {
		return null;
	}

	return new Product();

}
					{% endblock %}

					{% endembed %}
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}

					{% block rust %}
#[derive(Debug)]
struct Product {}

fn get_product(id : u32) -> Result<Option<Product>, ()> {

    if id == 1 {
        return Ok(None);
    }

    if id == 2 {
        return Err(());
    }

    Ok(Some(Product {}))
}

fn main() {
    println!("{:#?}", get_product(3));
}

					{% endblock %}

					{% endembed %}
				</section>

				<section>
					<img src="img/kotlin_operator1.png" />
					<img src="img/kotlin_operator2.png" />
					<aside class="notes">
							<ul>
								<li>? = elvis opetator</li>
								<li>!! = </li>
							</ul>
					</aside>
				</section>



				<section>
					<img src="img/maven_central.png"/>
				</section>
				<section>
					<img src="img/packagist_stats.png"/>
				</section>
				<section>
					<img src="img/crates_io.png"/>
				</section>
				<section>
					<img src="img/yew.png"/>
				</section>
				<section>
					<img src="img/web_view.png"/>
				</section>
				<section>
					<img src="img/redox.png"/>
				</section>
				<section>
					<img src="img/servo.png"/>
				</section>
				<section>
					<img src="img/rocket_rs.png"/>
				</section>
				<section>
					<img src="img/rust_diesel.png"/>
				</section>
				<section>
					<img src="img/rust_diesel2.png"/>
				</section>
				<section>
					<img src="img/rust_git.png"/>
				</section>
				<section>
					<img src="img/graalvm.png"/>
				</section>
				<section>
					<img src="img/bindgen.png"/>
				</section>
				<section>
					<img src="img/writing_an_os.png"/>
				</section>
				<section>
					<img src="img/rust_by_example.png"/>
				</section>
				<section>
					<img src="img/rust_book.png"/>
				</section>
				<section>
					<img src="img/libc.png"/>
				</section>
				<section>
					<img src="img/futures_rs.png"/>
				</section>
				<section>
					<img src="img/hello_rust_show.png"/>
				</section>
				<section>
					<img src="img/rust_neon.png"/>
				</section>
				<section>
					<img src="img/rust_osnabrück.png"/>
				</section>
				<section>
					<img src="img/rust_emulator.png"/>
				</section>
				<section>
					<img src="img/rust_team.png" style="max-width: 25%"/>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                width: "100%",
                height: "100%",
                margin: 0,
                minScale: 1,
                maxScale: 1,
                history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
