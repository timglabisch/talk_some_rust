<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/idea.css">

		<script src="jquery-3.0.0.min.js"></script>

		<style>
			iframe {
				max-width: 100% !important;
			}

			pre {
				box-shadow: none !important;
			}

			.right-code {
				border-left: 1px solid silver !important;
			}

			section img {
				border: 1px solid #ccc !important;
			}
		</style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<script type="application/javascript">
            $(document).ready(function() {
                $('.editor').each(function (i, v) {

                    $(v).css({
                        'height': $(document).height() - 100,
                        'border': '1px solid silver',
                        'display': 'flex',
                        'justify-content': 'flex-start'
                    });

                    var rust_pen = "http://127.0.0.1:5000";
                    //var rust_pen = "https://play.rust-lang.org/";

                    var rust_code = $(v).data('code-rust');


                    var php_code = $(v).data('code-php');


                    $(v).html('');

                    $(v).append($('<iframe style="flex: 1 1 auto;overflow:scroll"/>').attr('src', rust_pen + '/?pageMode=presentation&code=' + encodeURIComponent(rust_code)));


                    if (!php_code || !php_code.trim()) {
                        return;
                    }

                    var php_code_node = $('<div class="right-code"><pre><code data-trim data-noescape class="code"></code></pre></div>');
                    php_code_node.find('.code').text(php_code);
                    $(v).append($('<div style="flex: 1 1 auto;overflow:scroll"/>').html(php_code_node));

                });

                $('.editor > *').each(function(i, v) {
                    //$(v).css('margin', '10px');
                }).mouseenter(function(e) {
                    $(e.target).css('flex', '95 1 auto');
                    $(e.target).siblings().css('width', 100);
                    $(e.target).siblings().css('flex', '1 1 auto');
                })
                    .mouseleave(function(e) {
                        $(e.target).css('flex', '1 1 auto');
                        $(e.target).css('width', '');
                        $(e.target).siblings().css('width', '');
                    });
            });


		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    {% embed "twig/editor.html.twig" %}
                        {% block rust %}
pub fn main() {
	println!();
}
                        {% endblock %}

                        {% block php %}
<?php

echo "foo";
                        {% endblock %}
                    {% endembed %}

				</section>

					<section>
						<img src="img/me.jpeg" style="max-width:200px"><br/>
						<i>@timglabisch</i>
						<br/>
						<img src="img/github_stats.png" style="max-width:370px"/>
						<aside class="notes">
							<ul>
								<li>Ich bin Tim</li>
								<li>Wer schonmal hier aus der UG war und nicht über mich hinweg gesehen hat, hat mich bestimmt schonmal gesehen</li>
								<li>
									... Und Github denkt ich würde in diesen Sprachen entwickeln
									<ul>
										<li>Das ist definitiv falsch, ich mach kein Basic x)</li>
										<li>und CSS ist dieser Talk ^^</li>
										<li>gibt aber vielleicht ein ganz guten Überblick über meinen "sprachlichen" Background</li>
									</ul>
								</li>
								<li>
									Ich arbeite hier für Sensiolabs als Architekt, habe demnach einen starken PHP und Symfony Background
								</li>

								<li>
									Der Titel des Talks war ja Rust für PHP Devs
									<ul>
										<li>In diesem Sinne hab ich heute viel Code mitgebracht</li>
										<li>Ich hab aber auch viele Slides mitgebracht</li>
										<li>Sollte ich euch deutlich zu schnell werden, einfach aufschreien oder mit irgendwas nach mir werfen.</li>
										<li>
											Die Slides stelle ich online
											<ul>
												<li>Wenn man den Talk gewissenhaft nacharbeitet, kann man einige Stunden damit verbringen</li>
												<li>... und das ist gewollt so...</li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</aside>
					</section>

					<section>
                        {% embed "twig/editor.html.twig" %}
                        {% block rust %}
fn main() {
	println!("hello, Rheinjug!");
}
                        {% endblock %}

                        {% block php %}
// kotlin

fun main(args: Array<String>) {
	System.out.println("hello Rheinjug!");
}

// php
echo "Hello Rheinjug!";
						{% endblock %}
					{% endembed %}

					</section>
					<section>
                        {% embed "twig/editor.html.twig" %}
                        {% block rust %}
fn main() {
	let a: &[u8] = b"hello, Rheinjug!";
	println!("{}", ::std::str::from_utf8(a).expect("i am sure it's valid utf8"));
}
                        {% endblock %}

                        {% block php %}
// kotlin
import java.nio.charset.Charset

fun main(args: Array<String>) {
	val a = "Hello Rheinjug".toByteArray(Charset.defaultCharset());
	System.out.println(String.format("%s", a.toString(Charset.defaultCharset())));
}

// php
echo(sprintf("%s", "Hello Rheinjug!"));

                        {% endblock %}
                    {% endembed %}

						<aside class="notes">
							<ul>
								<li>nimmt man 3 sprachen, so hat man 3 unterschiedliche implementierungen was strings angeht.</li>
								<li>in rust gibt es 4 string typen, klassische sind strings immer utf8 und mutable</li>
								<li>strings in kotlin sind nicht mutable und nutzen wie java utf-16,  das default defaultCharset ist allerdings utf8. es gibt im issue tracker eine diskussion auf utf-8 zu wechseln.</li>
								<li>strings in php sind byte sequenzen. php6 ist dran gecheitert.</li>
								<li>
									wenn ihr bei php genau guckt, mal hab ich das echo mit klammern geschrieben, mal ohne.
									das ist eine besonderhet in php, echo ist ein eigener opcode.
									schaut man auf die rust implementierung siehst man das ausrufezeichen. Dabei handelt es sich nicht um ein sprachkonstrukt, sondern um ein macro.
								</li>
							</ul>
						</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(name);
}
					{% endblock %}

					{% block php %}
// kotlin
private fun greet(name : String) {
	System.out.println("Hello " + name);
}

fun main(args: Array<String>) {
	val name = "Rheinjug";
	greet(name)
}

// php
function greet(string $name) {
	echo sprintf(
		"Hello %s", $name
	);
}

$name = "PHPUG";
greet($name);



					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>Hier sehen wir eine Funktion welche aufgerufen wird (greet)</li>
								<li>Typisierung der Funktion (String) ist steht auf der rechten seite Kotlin und Rust machen dies identisch. Java und PHP nicht.</li>
								<li>ich werde für den Moment noch nicht auf das .to_string() eingehen, vielleicht schaffen wir das gleich noch</li>
							</ul>
						</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	pub age: i32
}

pub fn main() {
	let tim = Person { age: 25 };
	println!("tim is {} years old", tim.age);
}
					{% endblock %}

					{% block php %}
class Person(val age : Int);

fun main(args: Array<String>) {
	val tim = Person(25);
	System.out.println("tim is " + tim.age + " years old")
}

					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>In Rust definieren wir ein Strukt mit einer Property. in Kotlin eine Klasse.</li>
							<li>Strukts haben felder, Klassen haben properties</li>
							<li>
								Jede sprache hat eine andere ideologie. Sieht man z.b. daran:
								Kotlin ist public by default, Rust ist private by default.
								<ul>
									<li>Kotlin ist eher pragmatisch</li>
									<li>Rust versucht extrem korrekt und expliizit zu ein. werden wir noch öfters sehen.</li>
									<li>anderes beispiel, wir hatten eben da expect beim wandeln in utf8.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
struct Person {
	age: i32
}

impl Person {
	pub fn new(age: i32) -> Self {
		Person {
			age
		}
	}

	pub fn get_age(&self) -> i32 {
		self.age
	}
}

pub fn main() {
	let tim = Person::new(25);
	println!("tim is {} years old", tim.get_age());
}
					{% endblock %}

					{% block php %}
class Person(private val age : Int) {
	fun getAge(): Int {
		return this.age;
	}
}

fun main(args: Array<String>) {
	val tim = Person(25);
	System.out.println("tim is " + tim.getAge() + " years old")
}


					{% endblock %}
					{% endembed %}

						<aside class="notes">
							<ul>
								<li>hier das gleiche beipiel mit einem getter.</li>
								<li>
                                    hier sieht man deutliche unterschiede
                                    <ul>
                                        <li>Kotlin code ist weniger</li>
                                        <li>Rust kennt keinen Konstruktur, ist einfach eine statische methode, welche eine Instanz zurückgibt.</li>
										<li>Rust hat keine echten klassen, sieht mehr aus wie golang (impl für ein strukt)</li>
										<li>Rust trennt zustand (properties) von Funktionen.</li>
										<li>
											Rust nimmt speichermanagement extrem genau, sehen wir später noch.
											<ul>
												<li>
													in kotlin -> Person ist eine Instanz einer Klasse welche im Heap liegt.
												</li>
												<li>
													In Rust ist Person eine Datenstruktur der Größe Integer, welche auf dem Stack liegt. Kein Refcounting etc. Wer weiß, was refcounting ist? später mehr dazu.
												</li>
											</ul>
										</li>
                                    </ul>
                                </li>
							</ul>
						</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>

							<li>wenn man sich in projekten anguckt fühlt man sich mitlerweilse oft so.</li>
							<li>unsere technologielandschaft ähnelt in vielen Projekten oft eher einem Abenteuerspielplatz als einem enterprise projekt</li>

							<!--
							<li>
								da ganze hat 2 seiten
								<ul>
									<li>wir lernen grade software so zu implementieren, dass diese komponenten isoliert und wegwerfbar sind.</li>
									<li>software ist heute mehr wie eine PET-Flasche, man nuckelt dran und wirft ie weg.</li>
									<li>recruiting spielt da auch mit rein, viele wollen schlicht ausprobieren können.</li>
									<li>probiert man nicht aus, sammelt man keine erfahrung</li>
									<li>kunst liegt darin, gefahrlos auszuprobieren</li>
								</ul>
								<ul>
									<li></li>
								</ul>
							</li>
							-->

							<li>agile herangehensweisen machen es einfach mal was neues in ein projekt zu werfen, hype driven development ist gang und gebe</li>
							<li>die meisten entwickler haben mehr ajvascript frameworks selbst gebau, als das sie algorithmen implementieren können - so ist das eben heute, und ich finds auch nicht schlimm.</li>
							<li>in den letzten paar jahren ist die menge an technologien pro projekt extrem gestiegen, frameworks werden komplexer u.s.w.</li>
							<li>... und nun stelle ich euch mal wieder eine neue technologie vor, welche neue Hoffnung bringen soll. wie jede andere technologie mit der man sich rumschlägt.</li>

							<li>in dem talk möchte ich euch näher bringen, warum ich der meinung bin, dass rust nicht in dieses pattern fällt.</li>
							<li>-> schauen wir uns dazu mal die rust startseite an.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_lang_org_startpage1.png" />
					<aside class="notes">
						<aside class="notes">
							<ul>
								<li>Da schon wieder der Begriff system programming</li>
								<li>ist das kotlin auch? wohl eher web programming, mhhmm</li>
								<li>und rust will "schnell" sein</li>
								<li>ok, nichts neues, das sind C und C++ z.b. auch. und schnell ist ja eh relativ</li>
							</ul>
						</aside>
					</aside>
				</section>
					
				<section>
					<img src="img/system_prgramming_languages.png">
					<a href="https://en.wikipedia.org/wiki/System_programming_language">wikipedia.org/wiki/System_programming_language</a>
					<aside class="notes">
						<ul>
							<li>wikipedia listet 15 system programming languages</li>
							<li>das sind echt wenig sprachen, oder? wenn man mal danach schau, in welchen sprachen tatsächlich betriebsysteme / treiber geschrieben werden, wird die liste kürzer.</li>
							<li>ich bin ehrlich gesagt über swift gestolpert, weil es für mich keine wirkliche system programming language ist.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/swift_system_programming.png">
					<br/>
					<small>
						<a href="https://www.quora.com/Is-Swift-a-great-systems-programming-language">quora.com/Is-Swift-a-great-systems-programming-language</a>
					</small>
				</section>

				<section>
					<img src="img/language_ranking_with_tiobe.png">
					<aside class="notes">
						schaut man mal welche sprachen tatsächlich viel genutzt werden.
						das ist krass, C und C++ sind uralt und unter den ersten Plätzen.

					</aside>
				</section>


				<section>
					<img src="img/swift_system_programming.png">
					<br/>
					<small>
						<a href="https://www.quora.com/Is-Swift-a-great-systems-programming-language">quora.com/Is-Swift-a-great-systems-programming-language</a>
					</small>
				</section>

				<section>
					<img src="img/system_prgramming_languages_reduced.png">
					<aside class="notes">
						schaut man welche sprache heute tatsächlich noch relevanz haben, landet man meiner Meinung nach bei 3 Sprachen.
						Swift hatte ich raus genommen, weil ich es nicht als Konkurrent zu C / C++ sehe.

					</aside>
				</section>

				<section>
					<img src="img/more_than_a_hype.jpg" />
					<aside class="notes">
						<ul>

							<li>nun sieht man, dass es in dem bereich garnicht soviel gibt.</li>
							<li>nun könnte man sagen, ich will garkein C und C++ lernen, wofür dann rust?</li>
							<li>die 31 Jahre zeigen wie schwer es ist.</li>
							<li>mozilla hat rund 6 jahre forschung in die reinen sprachkonzepte gesteckt.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/rust_lang_org_startpage2.png">
					<aside class="notes">
						<ul>
							<li>prevents segfaults - kennt jemand segfaults?</li>
							<li>
								ich programmiere viel php, da sieht man schonmal häufig segfaults. php ist in C geschrieben.
								<ul>
									<li>PHP Intern sind und kein spass zum Debuggen machen</li>
									<li>hab ich häufiger mal wenn ich gewaltige tests suits laufen lasse</li>
									<li>
										Wäre PHP also in Rust geschrieben, dann könnte es diese art von Fehlern nicht geben?
										<ul>
											<li>Krass</li>
											<li>Absolutes alleinstellungsmerkmal unter "System programming" sprachen.</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								thread safety ist auch so ne sache
								<ul>
									<li>Threading ist hart</li>
									<li>Rust ist die erste sprache, welche thread safety erzwingen kann</li>
								</ul>
							</li>
							<li>
								Wie macht rust das alles?
								<ul>
									<li>Es kompilliert schlicht nicht, wenn es sich nicht sicher ist.</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>



				<section>
					<img src="img/cartoon_c.png" />
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
					</small>
					<aside class="notes">
						<ul>

							<li>...</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/cartoon_rust.png" style="max-height: 100%"/>
					<br/>
					<small>
						<a href="http://leftoversalad.com/c/015_programmingpeople/">leftoversalad.com/c/015_programmingpeople</a>
					</small>
					<aside class="notes">
						<ul>

							<li>nun sieht man, dass es in dem bereich garnicht soviel gibt.</li>
							<li>nun könnte man sagen, ich will garkein C und C++ lernen, wofür dann rust?</li>
							<li>die 31 Jahre zeigen wie schwer es ist.</li>
							<li>mozilla hat rund 6 jahre forschung in die reinen sprachkonzepte gesteckt.</li>
						</ul>
					</aside>
				</section>


				<section>
					<img src="img/rust_spoils_me.png"/>
					<br/>
					<small>
						<a href="https://twitter.com/gilescope/status/992309474881822720">twitter.com</a>
					</small>
				</section>

				<section>
					<img src="img/rust_spoils_me2.png"/>
					<br/>
					<small>
						<a href="https://twitter.com/gilescope/status/992309474881822720">twitter.com</a>
					</small>
				</section>

				<section>
					<h3>das tolle an Rust, sind dessen einschränkungen.</h3>
					<aside class="notes">
						<ul>

							<li>hört sich paradox an. wenn man drüber nachdenkt ergeben sich aus einschränkungen aber idr. Möglichkeiten.</li>
							<li></li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(name);
}
					{% endblock %}

					{% block php %}
// kotlin
private fun greet(name : String) {
	System.out.println("Hello " + name);
}

fun main(args: Array<String>) {
	val name = "Rheinjug";
	greet(name)
}

// php
function greet(string $name) {
	echo sprintf(
	"Hello %s", $name
	);
}

$name = "PHPUG";
greet($name);

					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>Beispiel von eben.</li>
							<li><span style="font-style: italic">greet kopieren.</span></li>
							<li>Wer kennt eine sprache in der das problematisch wäre?</li>
							<li>
								jemand eine idee warum rust das verbietet?
								<ul>
									<li></li>
								</ul>
							</li>
							<li>jemand eine idee wie man das fixen könnte?</li>
							<li>die einfachste variante wäre den String wieder zurückzugeben. Keine angst, geht auch eleganter</li>
							<li>string wieder zurückzugeben sieht doof aus, ist aber ultra performant, rust kann den code inlinen und quasi komplett entfernen.</li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/ownership_in_c.png"><br/>
					<aside class="notes">
						<ul>
							<li>Die Folie hab ich geklaut, hätte ich gerne verlinkt, link geht aber nicht mehr :)</li>
							<li>welche sprache ist das? - C natürlich</li>
							<li>wem von euch ist das problem klar?</li>
							<li>C und C++ haben grauenhafte methodensignaturen, weil sie idr. den RAM nicht selbst allocieren können.</li>
							<li>die frage ist immer wer das free() aufruft. in so kleinen anwendungen ist das kein Problem, ist man aber Mozilla, und hat millionen zeilen C++ code siehts übel aus.</li>
							<li>in c++ werden gerne smartpointer verwendet, bringen aber auchnachteile</li>
							<li>rust braucht dies hier nicht, ists unsicher, sagt der compiler schlicht nein. Performance ist besser als wenn man einen solchen smartpointer verwendet.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn greet(name : &String) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug".to_string();
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							<li>wir können eine Referenz übergeben.</li>
							<li>würden wir einen String übergeben. würde die Funktion diesen String besitzen. der Besitzer gibt den String wieder frei.</li>
							<li>Referenzen müssen nicht freigegeben werden. Irgendwo muss ja ein besitzer sein, und dieser wird diesen garantiert freigeben.</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
#![inline(always)]
pub fn greet(name : &str) {
	println!("Hello {}", name);
}

pub fn main() {
	let name = "Rheinjug";
	greet(&name);
}
					{% endblock %}
					{% endembed %}


					<aside class="notes">
						<ul>
							</ul>
					</aside>
				</section>
					
				<section>
					<small>
						<a href="https://rustup.rs">https://rustup.rs</a>
					</small>
					<br/>
					<img src="img/rustup.png" style="max-width: 50%">
				</section>

				<section>
					<img src="img/cargo_new_project.png">
					<aside class="notes">
						<ul>
							<li>cargo new legt euch ein neues projekt an</li>
							<li>--bin steht für binary, ohne wäre es eine statische lib.</li>
							<li>er initialisiert euch auch gleich ein git repo mit passender .gitignore</li>
							<li>cargo run baut das projekt und lässt es im debug mode laufen.</li>
							<li>cargo kümmert sich auch ums dependencymanagement.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>cargo</h2>
					<p>
						Cargo.toml / Cargo.lock
					</p>
					<img src="img/cargo_toml.png">
					<aside class="notes">
						<ul>
							<li>kein GOPATH oder sowas. Semver, lockfiles u.s.w.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>intellij</h2>
					<img src="img/intelli_rust.png">
					<aside class="notes">
						<ul>
							<li>support ist erschreckend gut. selbst macros etc.</li>
							<li>externe bibliotheken etc sind kein problem.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>RLS</h2>
					<img src="img/rust_language_server.jpg">
					<aside class="notes">
						<ul>
							<li>Rust kommt mit einem language server, funktioniert wie z.b. bei typeskript und hat daher guten support für visual stio code</li>
							<li>Compiler selbst gibt outocompletion etc. funktioniert sehr gut und wird immer besser.</li>
							<li>refactorings direkt im compiler, stimmen immer! :)</li>
							<li>intelli rust nutzt den language server nicht.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h2>namespaces / finding classes</h2>
					todo
				</section>

				<section>
					<h3>Tests</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
pub fn add_two(a: i32) -> i32 {
	a + 2
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn it_works() {
		assert_eq!(4, add_two(2));
	}
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>cargo doc generiert api docs</li>
							<li>beste api docs die ich kenne (mit suchfunktion)</li>
							<li>api docs fürs ganze projekt</li>
							<li>code beispiele werden als tests ausgeführt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Lets write a webserver</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
#![feature(plugin)]
#![plugin(rocket_codegen)]

extern crate rocket;

#[get("/")]
fn index() -> &'static str {
	"Hello, world!"
}

fn main() {
	rocket::ignite().mount("/", routes![index]).launch();
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						<ul>
							<li>gutes beispiel, sieht nicht so "low level" aus?</li>
							<li></li>
						</ul>
					</aside>
				</section>

				<section>
					<img src="img/rust_more_control_more_safety.png">
					<aside class="notes">
						<ul>
							<li>rust fühlt sich von den sprachkonstrukten nicht so low level an</li>
							<li>oft musst man bei sprachen zwischen controller und sicherheit wählen, rust versucht hier beides zu bieten.</li>
							<li>es dreht sich hier nur um controller / sicherheit.</li>
						</ul>
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let a;

	if true {
		a = "Ja";
	} else {
		a = "Nein";
	}

	println!("{}", a);
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						etliche variationen (unitialisiert / if return value))
						Rust -> safe
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let names = vec![
		"Tim",
		"Chris",
		"Freerich"
	];

	println!("{}", names.join(", "));
}


                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						einfache arrays ...
					</aside>
				</section>

				<section>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
fn main() {

	let mut names = vec![];
	names.push("Tim");
	names.push("Chris");
	names.push("Freerich");

	println!("{}", names.join(", "));
}
                    {% endblock %}
                    {% endembed %}
					<aside class="notes">
						arrays sind "veränderbar" nicht so wie bei c


						Compiler Warnung bei:

						fn main() {

						let mut names = Vec::new();

						println!("{}", names.join(", "));
						}
					</aside>
				</section>

				<section>


					{% embed "twig/editor.html.twig" %}
					{% block rust %}
#[derive(Debug)]
struct BlogPost;

fn get_blog_post_by_uuid(uuid : &str) -> Option<BlogPost> {
	if uuid == "1234-abcdef" {
		return Some(BlogPost {});
	}

	None
}

fn main() {
	println!("{:?}", get_blog_post_by_uuid("1234-abcdef"));
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>Rust kennt kein "Null"</li>
							<li>Rust kennt nur "options"</li>
							<li>kann das sein, oder nichts</li>
							<li>Prüft man nicht, sondern ruft einfach "unwrap" auf einer option auf, so panict im zweifel das programm und ist beendet</li>
							<li>das programm ist somit nie in einem "komischen" zustand</li>
							<li>benutzt man unwrap nicht, kann das programm in keinen dieser zustände kommen</li>
							<li>wer würde schon ein herzschrittmacher in php entwickeln?</li>
						</ul>
					</aside>
				</section>
				<section>


					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn get_blog_post_by_uuid(uuid : &str) -> Option<BlogPost> {
	if uuid == "1234-abcdef" {
		return Some(BlogPost {});
	}

	None
}

fn main() {
	println!("{:?}", get_blog_post_by_uuid("1234-abcdef").trim());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>


					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> String {
	reqwest::get("https://www.rust-lang.org")
		.unwrap()
		.text()
		.unwrap()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, String> {
	match reqwest::get("https://www.rust-lang.org") {
		Err(_) => Err("could not fetch www.rust-lang.org".to_string()),
		Ok(ref mut response) => {
			match response.text() {
				Err(_) => Err("could not decode text".to_string()),
				Ok(text) => Ok(text)
			}
		}
	}
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>


				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, String> {
	match reqwest::get("https://www.rust-lang.org") {
		Err(_) => Err("could not fetch www.rust-lang.org".to_string()),
		Ok(ref mut response) => {
			match response.text() {
				Err(_) => Err("could not decode text".to_string()),
				Ok(text) => Ok(text)
			}
		}
	}
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
extern crate reqwest;

pub fn fetch_google() -> Result<String, reqwest::Error> {
	reqwest::get("https://www.rust-lang.org")?.text()
}

pub fn main() {
	println!("{:#?}", &fetch_google());
}
					{% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
pub fn foo1() -> Result<String, ()> {
	Err(())
}

pub fn foo2() -> Result<String, ()> {
	Ok(foo1()?.trim().to_string())
}

pub fn main() {
	println!("{:#?}", foo2());
}
                    {% endblock %}
					{% endembed %}
					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>


				<section>
					{% embed "twig/editor.html.twig" %}
					{% block rust %}
fn main() {
	let numbers = vec![1, 2, 3, 4, 5, 6, 10, 100];

	let result: Vec<_> = numbers.iter()
	.filter(|&x| *x < 4)
	.filter(|&x| *x > 100)
	.map(|x| x * 2)
	.chain(10..11)
	.collect();

	println!("{:#?}", result);
}
					{% endblock %}
					{% endembed %}

					<aside class="notes">
						<ul>
							<li>foo</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Generics</h3>
                    {% embed "twig/editor.html.twig" %}
                    {% block rust %}
enum May<T> {
	Value(T),
	Empty
}

impl<T> May<T> {
	pub fn unwrap(&self) -> &T {
		match self {
			&May::Value(ref v) => v,
			&May::Empty => panic!("yolo")
		}
	}
}

fn main() {
	println!("{}", May::Value::<i32>(10).unwrap());
	println!("{}", (May::Empty::<i32>).unwrap());
}
					{% endblock %}
					{% endembed %}
				</section>

				<section>
					<img src="img/me.jpeg" style="max-width:200px"><br/>
					<i>@timglabisch</i>
					<br/>
					<img src="img/github_stats.png" style="max-width:370px"/>
					<aside class="notes">
						<ul>
							<li>Ich bin Tim</li>
						</ul>
					</aside>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                width: "100%",
                height: "100%",
                margin: 0,
                minScale: 1,
                maxScale: 1,
                history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
